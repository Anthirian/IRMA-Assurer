(*************************************************************************
 *** The Transport Layer Security (TLS) Handshake Protocol             ***
 ***        RSA encrypted Pre-Master Secret                            ***
 ***                                                                   ***
 *** Carst Tankink (0569954), Pim Vullers (0575766)                    ***
 *************************************************************************)
 
(**************************************************************************
 * DEFINITIONS                                                            *
 **************************************************************************)
 
(* A public channel *)
free net.

(* Message tags *)
free ClientHello, ClientKeyExchange, ClientCertificate, ServerHello, ServerCertificate, CertificateVerify.

(* Agent initialization is done over a private channel *)
private free initialClientData, initialServerData.

(* The cryptographic constructors *)
fun hash/1. 	(* hashing *)
fun encrypt/2. 	(* symmetric key encryption *)
fun pencrypt/2. (* Public key encryption *)
fun sign/2. 	(* Public key signing *)
fun enc/1. 		(* Extracts encryption key from a keypair *)
fun dec/1. 		(* Extracts decryption key from a keypair *)

(* The cryptographic destructors *)
reduc decrypt(encrypt(x, y), y) = x.
reduc pdecrypt(pencrypt(x, enc(y)), dec(y)) = x.
reduc unsign(sign(x, enc(y)), dec(y)) = x.

(* A constructor that maps agents to their secret keypairs *)
private fun pubkeypair/1.
private fun signkeypair/1.

(* Pseudo−random−number function *)
fun PRF/1.

(* Symmetric key construction *)
fun clientK/3.
fun serverK/3.

(* Certificates *)
private fun cert/2.

(* If cert(x, y) establishes x as owner of key y, y is returned *)
reduc verify(cert(x, y), x) = y.

(**************************************************************************
 * QUERIES 																  *
 **************************************************************************)
 
(* secrecy Pre Master secret *)
query attacker: PMS.

(* secrecy Master secret *)
query attacker: MSa.
query attacker: MSb.

(* secrecy Finished message from the client *)
query attacker: FinishedAFlag.

(* secrecy Finished message from the server *)
query attacker: FinishedBFlag.

(* authenticity of the server *)
query evinj: endServerAuth(x, y, z) ==> evinj: beginServerAuth(x, y, z).

(* authenticity of the client *)
query evinj: endClientAuth(x, y, z) ==> evinj: beginClientAuth(x, y, z).

(* Dead code check *)
query attacker: clientFinished.
query attacker: serverFinished.

(**************************************************************************
 * CLIENT PROCESS, this client is the initiator of the protocol.          *
 **************************************************************************)
let client =
	(** Initial agent data from a trusted channel **)
	in(initialClientData, (A, signKey, clientCert));
	
	(** Replication to model arbitrary sessions **)
	!
	
	(** Get the server’s name, perhaps as user input **)
	in(net, B);
	
	(* A generates fresh nonce Na *)
	new Na;
	
	(* A determines Sid, session is randomly generated in basic model *)
	new Sid;
	
	(* A chooses options Pa, options are just random data for our model *)
	new Pa;
	
	(* A −> B : ClientHello *)
	let CH = (ClientHello, A, Na, Sid, Pa) in out(net, CH);
	
	(* B −> A : ServerHello *)
	in(net, SH); let (=ServerHello, Nb, =Sid, Pb) = SH in
	
	(* B −> A : ServerCertificate *)
	in(net, SC); let (=ServerCertificate, serverCert) = SC in
	
	(* A −> B: ClientCertificate *)
	let CC = (ClientCertificate, clientCert) in out(net, CC);
	
	(* A generates secret PMS *)
	new PMS;
	
	(** begin client authentication **)
	event beginClientAuth(A, B, PMS);
	
	(* A −> B : ClientKeyExchange *)
	let encKey = verify(serverCert, B) in 
	let CKE = pencrypt((ClientKeyExchange, PMS), encKey) in out(net, CKE);
	
	(* A −> B: CertificateVerify *)
	let CV = sign((CertificateVerify, hash((Nb, B, PMS))), signKey) in out(net, CV);
	
	(* A calculates the Master secret M *)
	let M = PRF((PMS, Na, Nb)) in
	
	(* A calculates Finished *)
	let Finished = hash((CH, SH, SC, CC, CKE, CV, M)) in
	
	(* A −> B : Finished *)
	out(net, encrypt(Finished, clientK(Na, Nb, M)));
	
	(* B −> A : Finished *)
	in(net, FB);
	
	(* A verifies received finished *)
	let =Finished =decrypt(FB, serverK(Na, Nb, M)) in
	
	(** end server authentication **)
	event endServerAuth(A, B, PMS);
	
	(** secrecy check on the Master secret **)
	new MSa; out(M, MSa) |
	
	(** secrecy check on the Finished message **)
	new FinishedAFlag; out(Finished, FinishedAFlag) |
	
	(** dead code check **)
	new clientFinished; out(net, clientFinished).
	
(* *************************************************************************
* THE SERVER PROCESS *
************************************************************************* *)
let server =
	(** Initial agent data from a trusted channel **)
	in(initialServerData, (B, decKey, serverCert));
	
	(** Replication to model arbitrary sessions **)
	!
	
	(* A −> B : ClientHello *)
	in(net, CH); let (=ClientHello, A, Na, Sid, Pa) = CH in
	
	(* B generates fresh nonce Nb *)
	new Nb;
	
	(* B chooses options Pb, just some random data in our model *)
	new Pb;
	
	(* B −> A : ServerHello *)
	let SH = (ServerHello, Nb, Sid, Pb) in out(net, SH);
	
	(* B −> A : ServerCertificate *)
	let SC = (ServerCertificate, serverCert) in out(net, SC);
	
	(* A −> B : ClientCertificate *)
	in(net, CC); let (=ClientCertificate, clientCert) = CC in
	
	(* A −> B : ClientKeyExchange *)
	in(net, CKE); let(=ClientKeyExchange, PMS) = pdecrypt(CKE, decKey) in
	
	(* A −> B : CertificateVerify *)
	let unsignKey = verify(clientCert, A) in
	in(net, CV); let (=CertificateVerify, cvHash) = unsign(CV, unsignKey) in
	
	(* B verifies client signature *)
	let =cvHash = hash((Nb, B, PMS)) in
	
	(** end client authentication **)
	event endClientAuth(A, B, PMS);
	
	(* A −> B : Finished *)
	in(net, FA);
	
	(* B calculates M *)
	let M = PRF((PMS, Na, Nb)) in
	
	(* B calculates Finished *)
	let Finished = hash ((CH, SH, SC, CC, CKE, CV, M)) in
	
	(** server authentication **)
	event beginServerAuth(A, B, PMS);
	
	(* B −> A : Finished *)
	out(net, encrypt(Finished, serverK(Na, Nb, M)));
	
	(* B verifies received Finished *)
	let =Finished = decrypt(FA, clientK(Na, Nb, M)) in
	
	(** secrecy check on the Master secret **)
	new MSb; out(M, MSb) |
	
	(** secrecy check on the finished **)
	new FinishedBFlag; out(Finished, FinishedBFlag) |
	
	(** dead code check **)
	new serverFinished; out(net, serverFinished).
	
(**************************************************************************
 * THE INITIALIZER PROCESS                                                *
 **************************************************************************)
let initializer =
	new agent; (* Generate agent name *)
	let clientKeyPair = signkeypair(agent) in (* Generate client key *)
	let serverKeyPair = pubkeypair(agent) in (* Generate server key *)
	let clientCert = cert(agent, dec(clientKeyPair)) in
	let serverCert = cert(agent, enc(serverKeyPair)) in
	out(initialClientData, (agent, enc(clientKeyPair), clientCert));
	out(initialServerData, (agent, dec(serverKeyPair), serverCert));
	out(net, agent).
(**************************************************************************
 * THE SYSTEM                                                             *
 **************************************************************************)
process
	!initializer | !client | !server