(**************************************************************************
 * DEFINITIONS                                                            *
 **************************************************************************)
 
(* param verboseClauses = explained. *)
(* param traceDisplay = long. *)

(* A public channel *)
free net.

(* The secure channel negotiated during the TLS handshake *)
private free s.

(* Message tags *)
free ClientPassport, ActiveAuthenticationChallenge, ActiveAuthenticationReponse, TransferABC.

(* Agent initialization is done over a private channel *)
private free clientInit, serverInit, initChannel.

(* The cryptographic constructors *)
fun hash/1. 	(* hashing *)
fun hmac/2.
fun encrypt/2. 	(* symmetric key encryption *)
fun sign/2. 	(* Public key signing *)
fun sk/1. 	(* Extracts secret key of a keypair *)
fun pk/1. 	(* Extracts public key of a keypair *)

(* The cryptographic destructors *)

reduc decrypt(encrypt(x, y), y) = x.
reduc unsign(sign(x, sk(y)), pk(y)) = x.

(* A constructor that maps agents to their secret keypairs *)
private fun keypair/1.

(**************************************************************************
 * QUERIES 																  *
 **************************************************************************)

 (* Secrecy passport and attribute data *)
query attacker: passportFlag.
query attacker: ABCflag.

(* Passport checks *)
query evinj: endPassiveAuth(x, y, z) ==> evinj: beginPassiveAuth(x, y, z).
query evinj: endActiveAuth(x, y, z) ==> evinj: beginActiveAuth(x, y, z).

(* ABC transaction check *)
query evinj: endTransaction(x, y, z) ==> evinj: beginTransaction(x, y, z).

(* Dead code check *)
query attacker: clientFinished.
query attacker: serverFinished.

(**************************************************************************
 * THE SERVER PROCESS                                                     *
 **************************************************************************)
let Server =
	in(serverInit, (A, B, sessionKey));
	
	in(initChannel, (=B, issuerKeypair));
	let SKi = sk(issuerKeypair) in (* Secret key used for signing of attributes *)
	(* Start of application data *)
	
	(* Receiving the encrypted passport (EP) and its HMAC (HP) *)
	in(s, CP); let (=ClientPassport, EP, HP) = CP in

	(* Decrypt the passport data (DP) *)
	let DP = decrypt(EP, sessionKey) in

	(* Verify the HMAC *)
	let =HP = hmac(EP, sessionKey) in

	(* Verify the participants and store the nonce for after passport checks *)
	let (Passport, =A, =B, Nonce) = DP in
	
	(* Split up passport and store public key *)
	(* Note: If BAC is required, everything is inaccessible until BAC is performed *)
	(* We assume BAC is performed once we get to this part *)
	let (DG, SOD, PKp) = Passport in

	(* Do Passive Authentication by verifying the hash of the datagroups against the SOD file *)
	let =SOD = hash(DG) in

	event endPassiveAuth(A, B, Passport);

	(* Start Active Authentication by sending a challenge *)
	new AAC;

	event beginActiveAuth(A, B, AAC);

	out(s, (ActiveAuthenticationChallenge, AAC));

	(* Receive the response and verify if it is the correct solution *)
	in(s, AAR); let (=ActiveAuthenticationReponse, AAResp) = AAR in

	let =AAC = unsign(AAResp, PKp) in
	
	event endActiveAuth(A, B, AAC);

	(* Start of ABC logic *)

	(* Create a new characteristic, such as "student" or "male" *)
	new Char;

	(* Turn the characteristic into an ABC using the issuer's private key *)
	let ABC = sign(Char, SKi) in

	event beginTransaction(A, B, ABC);

	(* Create attribute data (AD) including participants and the previously received nonce *)
	let AD = (ABC, A, B, Nonce) in

	(* Encrypt the attribute data (EA) *)
	let EA = encrypt(AD, sessionKey) in

	(* Generate the HMAC over the encrypted attributes (HA) *)
	let HA = hmac(EA, sessionKey) in

	(* Send the encrypted data and its HMAC *)
	let ABCdata = (EA, HA) in out(s, (* (TransferABC,*) ABCdata);

	(* End of ABC logic *)

	(* End of application data *)

	(* Secrecy checks *)
	(
		(new ABCflag; out(ABCdata, ABCflag)) |
		
		(** dead code check **)
		(new serverFinished; out(net, serverFinished))
	).	
	

(**************************************************************************
 * CLIENT PROCESS, this client is the initiator of the protocol.          *
 **************************************************************************)
let Client =
	(* TODO: Is this OK for obtaining the session key? Share DH parameters or just receive entire key? *)
	in(clientInit, (A, B, sessionKey));
	
	(** Start of application data **)
	
	(* Build passport (data is actually received through a separate process) *)
	new DG; (* 16 data groups in total *)
	let SOD = hash(DG) in (* Contains hashes of all DG values *)
	new P; (* Create new passport agent (only part of the model, not part of passport) *)
	let passportKeypair = keypair(P) in (* Public key is technically stored in DG15 *)

	let Passport = (DG, SOD, pk(passportKeypair)) in

	event beginPassiveAuth(A, B, Passport); (* TODO: Add P to event? *)
	
	(* Generating fresh nonce for passport communication *)
	new Np;
	
	(* Encrypting passport using the session key *)
	let EP = encrypt((Passport, A, B, Np), sessionKey) in
	
	(* Generating HMAC of the encrypted passport, again reusing the session key *)
	let HP = hmac(EP, sessionKey) in
	
	(* Send the entire passport data *)
	let CP = (ClientPassport, EP, HP) in out(s, CP);
	
	(* Start of Active Authentication *)

	(* Receive challenge from Server *)
	in(s, AAC); let (=ActiveAuthenticationChallenge, Ch) = AAC in
	
	(* Send response to AA challenge *)
	let AAR = (ActiveAuthenticationReponse, sign(Ch, sk(passportKeypair))) in out(s, AAR);

	(* End of Active Authentication *)

	(* Start of ABC logic *)

	(* S -> C: {[{attr_1}SK_s, {attr_2}SK_s, ...], C, S, nonce}K_ts, HMAC *)
	(* in(s, applicationdata); let (=TransferABC, ABCs) = applicationdata in *)
	
	in(s, ABCs); let (EA, HA) = ABCs in
	
	

	(* Check the HMAC *)
	let =HA = hmac(EA, sessionKey) in

	(* Decrypt the Attribute Data (AD) *)
	let AD = decrypt(EA, sessionKey) in

	(* Verify the participants and the nonce and store the ABC(s) *)
	let (ABCdata, =A, =B, =Np) = AD in
	

	event endTransaction(A, B, ABCdata);

	(* End of ABC logic *)

	(* End of application data *)

	(* Secrecy checks *)
	(
		(new clientFinished; out(net, clientFinished)) |
		(new passportFlag; out(CP, passportFlag))
		
		(** dead code check **)
		
	).	

(**************************************************************************
 * THE INITIALIZER PROCESS                                                *
 **************************************************************************)
let initializer =
	new C; (* Generate agent name (unique) *)
	new S; (* Generate agent name (unique) *)
	new sessionKey;
	let issuerKeypair = keypair(S) in (* Generate issuer keypair *)
	(
		out(clientInit, (C, S, sessionKey)) |
		out(serverInit, (C, S, sessionKey)) |
		out(initChannel, (S, issuerKeypair)) |
		out(net, S) (* Inform clients of the central server (e.g. IP address) *)
	).
	
(**************************************************************************
 * THE SYSTEM                                                             *
 **************************************************************************)
process
	!initializer | !Client | !Server