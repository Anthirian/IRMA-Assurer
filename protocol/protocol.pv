(* The channel *)
free c.

(* Names *)
free T, S.

(* Keys and application data *)
private free key, attributes.

(* Public key derivation *)
fun pk/1.

(* Diffie-Hellman functions *)
fun f/2.
fun g/1.
equation f(x, g(y)) = f(y, g(x)).

(* Cryptographic functions *)
fun encrypt/2.
fun sencrypt/2.

reduc decrypt(encrypt(x, pk(y)), y) = x.
reduc sdecrypt(sencrypt(x, y), y) = x.

(* Signing functions *)
fun sign/2.
reduc getmess(sign(m, k)) = m.
reduc checksign(sign(m, k), pk(k)) = m.

(* Hash functions *)
fun hmac/2.

(* Queries *)
not SK_s.
not SK_t.
not key.
not ppData.
not attributes.

query attacker: attributes.
query attacker: key.

(* 
	Queries maken voor authenticity, confidentiality, accountability, auditability.
	
	Gebruik maken van TLS 1.2 i.c.m. ECC levert Perfect Forward Secrecy op. Dit betekent verder dat deze tunnel zorgt voor privacy en integrity. Hiervoor hoeven geen queries te worden opgenomen (?).
*)

(* Processes *)
let Tablet =
	(* Store the received public key, not knowing whose it is *)
	in (c, PK_x);
	(* Read out the data on the passport (not part of this protocol) *)
	new ppData;
	
	(* Start of DH *)
	
	(* Generate fresh nonce *)
	new n0;
	(* Sign e^n0 and send it, along with your public key *)
	out(c, (sign(g(n0), SK_t), PK_t));
	(* Wait for the response *)
	in(c, m1);
	(* Verify  signature and extract message *)
	let x1 = checksign(m1, PK_x) in
		(* Compute shared key using both nonces and the generator *)
		let key = f(n0, x1) in
		(* Ensure the received public key belongs to the server *)
			if PK_x = PK_s then
				
				(* End of DH *)
				
				(* Send encrypted message and its HMAC *)
				new nA;
				out(c, (encrypt((ppData, T, S, nA), key), hmac(ppData, key)));
				
				(* Wait for response *)
				in(c, resp);
				
				(* Split up response and verify the HMAC *)
				let (body, hmac_server) = resp in
					if hmac_server = hmac(body, key) then
						(* Decrypt the response body, verify that T, S, and nA are correct and finally store the signed attributes *)
						let (attributes, =T, =S, =nA) = sdecrypt(body, key) in
							event end(T, S, attributes).

let Server = 
	(* Start of DH *)
	
	(* Listen for authentication request *)
	in(c, (m0, PK_y));
	(* Verify signature and extract message *)
	let x0 = checksign(m0, PK_y) in
		(* Create new nonce *)
		new n1;
		(* Compute shared key using both nonces and the generator *)
		let key = f(n1, x0) in
			(* Sign e^n1 and send it, along with your public key *)
			out(c, sign(g(n1), SK_s));
			
			(* End of DH *)
			
			(* Receive sign-and-verify request from Tablet *)
			in(c, message_from_tablet);
			(* Split up message into content and hmac, and verify integrity *)
			let (message_content, hmac_tablet) = message_from_tablet in
				if hmac_tablet = hmac(message_content, key) then
					(* Check if the correct participants are included (T and S) and store the nonce *)
					event begin(T, S, attributes);
					let (user_specific_data, =T, =S, n) = sdecrypt(message_content, key) in
						(* Server checks user_specific_data internally *)
						
						(* We assume the data is valid, because checking it is not in the scope of this protocol *)
						
						(* Send the response message *)
						out(c, ((sign(user_specific_data, key), T, S, n), hmac(sign(user_specific_data, key), key))).

process
	(* Create a public key for both parties *)
	new SK_s;
	let PK_s = pk(SK_s) in
		out(c, PK_s);
		new SK_t;
		let PK_t = pk(SK_t) in
			(* Distribute the public keys *)
			out(c, PK_t);
			(* Start both processes *)
			((!Tablet) | (!Server))



(* Application Protocol
---------------------------

	- C controleert integriteit paspoortdata
	- C genereert HMAC
	- C versleutelt bericht met sessiesleutel

3. C -> S			{data, C, S, nonce}K_cs, HMAC

	- S checkt HMAC
	- S checkt C en S
	- S checkt counter/nonce
	- S checkt ID data
	
	- S signt IRMA data
	- S genereert HMAC
	- S versleutelt bericht met sessiesleutel
																
6. S -> C			{[{attr_1}SK_s, {attr_2}SK_s, ...], C, S, nonce}K_ts, HMAC

	- C checkt HMAC
	- C checkt C en S
	- C checkt counter/nonce
	
	- C verwerkt data tot attributen
*)

(* TLS in Alice Bob notation (niet mutually authenticated, want client stuurt nog geen certificaat)
http://www.ai.rug.nl/mas/finishedprojects/2011/TLS/hermsencomputerservices.nl/mas/visualisation.html


ClientHello
1.	C -> S: nC
2.	S -> C: N_S, CertChain_S, g, n, g^y, {N_C, N_S, g, n, g^y}pk_S, Root CAs
3.	C -> S: CertChain_C, g^x, {all_previous_messages}pk_C, ChangeCipherSpec, MAC_SK("client finished", all_previous_messages)													
4.	S -> C: ChangeCipherSpec, MAC_SK("server finished", all_previous_messages)

SK = #(g^xy, "master secret", N_C, N_S)


The TLS Handshake Protocol involves the following steps:

   -  Exchange hello messages to agree on algorithms, exchange random
      values, and check for session resumption.

   -  Exchange the necessary cryptographic parameters to allow the
      client and server to agree on a premaster secret.

   -  Exchange certificates and cryptographic information to allow the
      client and server to authenticate themselves.

   -  Generate a master secret from the premaster secret and exchanged
      random values.

   -  Provide security parameters to the record layer.

   -  Allow the client and server to verify that their peer has
      calculated the same security parameters and that the handshake
      occurred without tampering by an attacker.

	  
				Figure 1.  Message flow for a full handshake
      Client                                               Server

      ClientHello                  -------->
                                                      ServerHello
                                                     Certificate*
                                               ServerKeyExchange*
                                              CertificateRequest*
                                   <--------      ServerHelloDone
      Certificate*
      ClientKeyExchange
      CertificateVerify*
      [ChangeCipherSpec]
      Finished                     -------->
                                               [ChangeCipherSpec]
                                   <--------             Finished
      Application Data             <------->     Application Data

	  
	  



*)
