(**************************************************************************
 * DEFINITIONS                                                            *
 **************************************************************************)
 
(* param verboseClauses = explained. *)
(* param traceDisplay = long. *)

(* A public channel *)
free net.

(* Message tags *)
free ClientHello, ServerHello, ServerCertificate, ServerKeyExchange, ClientCertificateRequest, ServerHelloDone, ClientCertificate, ClientKeyExchange, CertificateVerify, ClientChangeCipherSpec, ClientFinished, ServerChangeCipherSpec, ServerFinished.

(* Agent initialization is done over a private channel *)
private free clientInit, serverInit.

(* The cryptographic constructors *)
fun hash/1. 	(* hashing *)
fun hmac/2.
fun encrypt/2. 	(* symmetric key encryption *)
fun sign/2. 	(* Public key signing *)
fun enc/1. 	(* Extracts encryption key from a keypair *)
fun dec/1. 	(* Extracts decryption key from a keypair *)

(* The cryptographic destructors *)

reduc decrypt(encrypt(x, y), y) = x.
reduc unsign(sign(x, enc(y)), dec(y)) = x.

(* A constructor that maps agents to their secret keypairs *)
private fun keypair/1.

(* Pseudo−random−number function for generating TLS session key randomness *)
fun PRF/1.

(* Symmetric key construction *)
fun clientK/3.
fun serverK/3.

(* Certificates *)
private fun cert/2.

(* If cert(x, y) establishes x as owner of key y, y is returned, i.e. this retrieves the public key from the server's certificate *)
reduc verify(cert(x, y), x) = y.

(* Diffie-Hellman computations *)
fun g/0. 					(* Generator of the group (a constant) *)
fun exp/2.					(* Exponentiation *)
equation exp(exp(g, x), y) = exp(exp(g, y), x). (* Equality property *)

(**************************************************************************
 * QUERIES 																  *
 **************************************************************************)
 
(* secrecy Pre Master secret *)
query attacker: PMSa.
query attacker: PMSb.

(* secrecy Master secret *)
query attacker: MSa.
query attacker: MSb.

(* secrecy Finished message from the client *)
query attacker: FinishedAFlag.

(* secrecy Finished message from the server *)
query attacker: FinishedBFlag. 

(* authenticity of the server *)
query evinj: endServerAuth(x, y, z) ==> evinj: beginServerAuth(x, y, z).

(* authenticity of the client *)
query evinj: endClientAuth(x, y, z) ==> evinj: beginClientAuth(x, y, z).

(* Passport checks *)
query evinj: endPassiveAuth(x, y, z) ==> evinj: beginPassiveAuth(x, y, z).
query evinj: endActiveAuth(x, y, z) ==> evinj: beginActiveAuth(x, y, z).

(* ABC transaction check *)
query evinj: endTransaction(x, y, z) ==> evinj: beginTransaction(x, y, z).

(* Dead code check *)
query attacker: clientFinished.
query attacker: serverFinished.

(**************************************************************************
 * THE SERVER PROCESS                                                     *
 **************************************************************************)
let Server =
	(** Initial agent data from a trusted channel **)
	in(serverInit, (B, keypair, serverCert));
	
	in(initChannel, (=S, SKi, issuerCert)); (* TODO: Initialize issuer keypair over separate channel? *)
	
	let SKs = enc(keypair) in
	
	(** Replication to model arbitrary sessions **)
	!
	
	(* A −> B : ClientHello *)
	in(net, CH); let (=ClientHello, A, Na, SupportedOptions) = CH in
	
	(* B generates fresh nonce Nb *)
	new Nb;
	
	(* Server picks a cipher suite and compression method from SupportedOptions *)
	new SelectedOptions;
	
	(* B −> A : ServerHello *)
	let SH = (ServerHello, B, Nb, SelectedOptions) in out(net, SH);
	
	(* B −> A : ServerCertificate *)
	let SC = (ServerCertificate, serverCert) in out(net, SC);
	
	(* Generate Diffie-Hellman Key Exchange parameters *)
	new N; (* Modulus (prime), public *)
	new Y; (* Server's secret exponent *)
	
	(* B -> A: ServerKeyExchange *)
	let SKE = (ServerKeyExchange, g, N, exp(g, Y), sign((Na, Nb, g, N, exp(g, Y)), SKs)) in out(net, SKE);
	
	(* Create a list of acceptable certificate types and CAs *)
	new Acceptable_certificate_types;
	new Acceptable_certificate_authorities;
	
	(* Sending ClientCertificateRequest *)
	let CCR = (ClientCertificateRequest, Acceptable_certificate_types, Acceptable_certificate_authorities) in out(net, CCR);
	
	(* Sending ServerHello Done *)
	let SHD = ServerHelloDone in out(net, SHD);
	
	(* A −> B : ClientCertificate *)
	in(net, CC); let (=ClientCertificate, clientCert) = CC in
	
	(* A −> B : ClientKeyExchange *)
	in(net, CKE); let (=ClientKeyExchange, GX) = CKE in
	
	(* A −> B : CertificateVerify *)
	let unsignKey = verify(clientCert, A) in
	in(net, CV); let (=CertificateVerify, cvHash) = unsign(CV, unsignKey) in
	
	(* B verifies client signature *)	
	let =cvHash = hash((CH, SH, SC, SKE, CCR, SHD, CC, CKE)) in
	
	(** end client authentication **)
	event endClientAuth(A, B, cvHash);
	
	(* Calculating the Pre-Master Secret *)
	let PMS = exp(GX, Y) in
	
	(* Receiving ClientChangeCipherSpec *)
	in(net, CCCS); let =ClientChangeCipherSpec = CCCS in
	
	(* A −> B : Finished *)
	in(net, FA);
	
	(* B calculates M *)
	let M = PRF((PMS, Na, Nb)) in
	
	(* B calculates Finished *)
	let Finished = hash((CH, SH, SC, SKE, CCR, SHD, CC, CKE, CV, CCCS, M)) in
	
	(** server authentication **)
	event beginServerAuth(A, B, Finished);
	
	(* Sending ServerChangeCipherSpec, indicating a switch to the encryption negotiated above. Essentially just 1 byte *) 	
	let SCCS = ServerChangeCipherSpec in out(net, SCCS);
		
	(* B −> A : Finished *)
	out(net, encrypt(Finished, serverK(Na, Nb, M)));
	
	(* B verifies received Finished *)
	let =Finished = decrypt(FA, clientK(Na, Nb, M)) in
		
	(* Sending ServerFinished, using the newly negotiated encryption *)
	out(net, encrypt((ServerFinished, Finished), sessionKey));
	
	(* End of TLS handshake *)	
	
	(* Set up a new secure channel encrypted with the newly generated session key *)
	new s;
	out(net, encrypt(s, sessionKey));
	
	(* Start of application data *)
	
	(* Receiving the passport *) (* C -> S: {data, C, S, nonce}K_cs, HMAC *)
	in(s, ClientPassport); let (EncryptedPassport, HMACPassport) = ClientPassport in
	
	(* Decrypt the passport data *)
	let DecryptedPassport = decrypt(EncryptedPassport, sessionKey) in
	
	(* Verify the HMAC *)
	let =HMACPassport = hmac(EncryptedPassport, sessionKey) in
	
	(* Verify the participants and store the nonce for after passport checks *)
	let (Passport, =C, =S, Nonce) = DecryptedPassport in
	
	(* Split up passport and store public key *)
	(* Note: If BAC is required, everything is inaccessible until BAC is performed *)
	(* We assume BAC is performed once we get to this part *)
	let (DataGroups, SecurityObject, PKp) = Passport in
	
	(* Do Passive Authentication *)
	let =SecurityObject = hash(DataGroups) in
	
	event endPassiveAuth(C, S, Passport);
	
	(* Start Active Authentication by sending a challenge *)
	new AAChallenge;
	
	event beginActiveAuth(C, S, AAChallenge);
	
	out(s, AAChallenge);
	
	(* Receive the response and verify if it is the correct solution *)
	in(s, AAResponse); let =AAChallenge = unsign(AAResponse, PKp) in
	
	(* The Server assumes the passport to be valid and proceeds with generating ABCs *)
	
	(* Start of ABC logic *)
	
	(* Create a new characteristic, such as "student" or "male" *)
	new Characteristic;
	
	(* Turn the characteristic into an ABC using the issuer's private key *)
	(* TODO: Issuer keypair is initialized, but not being received yet *)
	let AttributeBasedCredential = sign(Characteristic, SKi) in
	
	event beginTransaction(C, S, AttributeBasedCredential);
	
	(* Create attribute data including participants and the previously received nonce *)
	let AttributeData = (AttributeBasedCredential, C, S, Nonce) in
	
	(* Encrypt the attribute data *)
	let EncryptedAttributes = encrypt(AttributeData, sessionKey) in
	
	(* Generate the HMAC over the encrypted data *)
	let HMACAttributes = hmac(EncryptedAttributes, sessionKey) in
	
	(* Send the encrypted data and its HMAC *)
	let ABCs = (EncryptedAttributes, HMACAttributes) in out(s, ABCs);
	
	(* End of ABC logic *)
	
	(* End of application data *)
	
	(* Secrecy checks *)
	(
		(** secrecy check on the Master secret **)
		(new MSb; out(M, MSb)) |
		
		(** secrecy check on the Pre-Master Secret **)
		(new PMSb; out(PMS, PMSb)) |
		
		(** secrecy check on the finished **)
		(new FinishedBFlag; out(Finished, FinishedBFlag)) |
		
		(** dead code check **)
		(new serverFinished; out(net, serverFinished))
	).
	
(**************************************************************************
 * CLIENT PROCESS, this client is the initiator of the protocol.          *
 **************************************************************************)
let Client =
	(** Initial agent data from a trusted channel **)
	in(clientInit, (A, keypair, clientCert));
	
	let SKc = enc(keypair) in
	
	(** Get the server’s name, perhaps as user input **)
	in(net, B);
	
	(* A generates fresh nonce Na *)
	new Na;
	
	(* Supported cipher suites and compression methods *)
	new SupportedOptions;
	
	(* A −> B : ClientHello *)
	let CH = (ClientHello, A, Na, SupportedOptions) in out(net, CH);
	
	(* B −> A : ServerHello *)
	in(net, SH); let (=ServerHello, =B, Nb, SelectedOptions) = SH in
	
	(* B −> A : ServerCertificate *)
	in(net, SC); let (=ServerCertificate, serverCert) = SC in
	
	(* Receiving Server DH Key Parameters and checking integrity *)
	in(net, SKE); let (=ServerKeyExchange, G, N, GY, DHSignature) = SKE in
	let unsignKey = verify(serverCert, B) in
	let (=Na, =Nb, =g, =N, =GY) = unsign(DHSignature, unsignKey) in
	
	(* Receiving ClientCertificateRequest *)
	in(net, CCR); let (=ClientCertificateRequest, Acceptable_certificate_types, Acceptable_certificate_authorities) = CCR in
	
	(* Receiving ServerHelloDone *)
	in(net, SHD); let =ServerHelloDone = SHD in
	
	(* A −> B: ClientCertificate *)
	let CC = (ClientCertificate, clientCert) in out(net, CC);
	
	(* A −> B : ClientKeyExchange *)
	new X;
	let CKE = (ClientKeyExchange, exp(g, X)) in out(net, CKE);
	
	(* Creating hash of past messages *)
	let cvHash = hash((CH, SH, SC, SKE, CCR, SHD, CC, CKE)) in
	
	(** begin client authentication **)
	event beginClientAuth(A, B, cvHash);
	
	(* A −> B: CertificateVerify *)
	let CV = sign((CertificateVerify, cvHash), SKc) in out(net, CV);
	
	(* Compute the pre-master secret (g^xy) *)
	let PMS = exp(GY, X) in
	
	(* Compute the master secret, technically also requires "master secret" to be part of the arguments for hashing *)
	let M = PRF((PMS, Na, Nb)) in
	
	(* Sending ClientChangeCipherSpec, indicating a switch to the encryption negotiated above. Essentially just 1 byte *)
	let CCCS = ClientChangeCipherSpec in out(net, CCCS);
	
	(* Compute hash and session key *)
	let Finished = hash((CH, SH, SC, SKE, CCR, SHD, CC, CKE, CV, CCCS, M)) in
	
	(* A −> B : Finished *)
	out(net, encrypt(Finished, clientK(Na, Nb, M)));
	
	(* Receiving ServerChangeCipherSpec, indicating a switch to the encryption negotiated above. Essentially just 1 byte *)
	in(net, SCCS); let =ServerChangeCipherSpec = SCCS in
	
	(* B −> A : Finished *)
	in(net, FB);
	
	(* A verifies received finished *)
	let =Finished = decrypt(FB, serverK(Na, Nb, M)) in
	
	(** end server authentication **)
	event endServerAuth(A, B, Finished);
	
	(* End of TLS handshake *)
	
	(* Receive the secure channel created by the server *)
	in(net, newChannel); let s = decrypt(newChannel, sessionKey) in
	
	(* Start of application data *)	
	
	(* C -> S: {data, C, S, nonce}K_cs, HMAC *)
	
	(* Perform Passive + Active Authentication on the passport *)
	
	(* 
	Passport has keypair. 
	Private key stored in secure memory of chip. 
	Public key stored in SOD file. 
	Server obtains public key.
	Server issues challenge.
	Passport solves challenge using private key. 
	Server checks result using public key
	Active Authentication finished.
	*)
	
	(* "Create" passport *)
	new DataGroups; (* 16 data groups in total *)
	let SecurityObject = hash(DataGroups) in (* Contains hashes of all DG values *)
	new keypair; (* Public key is technically stored in DG15 *)
	let Passport = (DataGroups, SecurityObject, pk(keypair)) in
	
	event beginPassiveAuth(C, S, Passport);
	
	(* Encrypt the passport, reusing the session key *)
	new nA; (* A fresh nonce *)
	let EncryptedPassport = encrypt((Passport, C, S, nA), sessionKey) in
	
	(* Generate HMAC of the encrypted passport, again reusing the session key *)
	let HMACPassport = hmac(EncryptedPassport, sessionKey) in
	
	(* Send the entire passport data *)
	let ClientPassport = (EncryptedPassport, HMACPassport) in out(s, ClientPassport);
	
	(* Start of Active Authentication *)
	
	(* Receive challenge from Server *)
	in(s, AAChallenge);
	
	(* Send response to AA challenge *)
	let AAResponse = sign(AAChallenge, sk(keypair)) in out(s, AAResponse);
	
	(* End of Active Authentication *)
	
	(* Start of ABC logic *)
	
	(* S -> C: {[{attr_1}SK_s, {attr_2}SK_s, ...], C, S, nonce}K_ts, HMAC *)
	in(s, ABCs); let (EncryptedAttributes, HMACAttributes) = ABCs in
	
	(* When we receive attributes it is safe to assume active authentication succeeded *)
	event endActiveAuth(C, S, AAChallenge);
	
	(* Check the HMAC *)
	let =HMACAttributes = hmac(EncryptedAttributes, sessionKey) in
	
	(* Decrypt the Attributes *)
	let AttributeData = decrypt(EncryptedAttributes, sessionKey) in
	
	(* Verify the participants and the nonce and store the ABC(s) *)
	let (AttributeBasedCredential, =C, =S, =nA) = AttributeData in
	
	event endTransaction(C, S, AttributeBasedCredential);
	
	(* End of ABC logic *)
	
	(* End of application data *)
	
	(* Secrecy checks *)
	(
		(** secrecy check on the Master secret **)
		(new MSa; out(M, MSa)) |
		
		(** secrecy check on the Pre-Master Secret **)
		(new PMSa; out(PMS, PMSa)) |
		
		(** secrecy check on the Finished message **)
		(new FinishedAFlag; out(Finished, FinishedAFlag)) |
		
		(** dead code check **)
		(new clientFinished; out(net, clientFinished))
	).
				
(**************************************************************************
 * THE INITIALIZER PROCESS                                                *
 **************************************************************************)
let initializer =
	new C; (* Generate agent name (unique) *)
	new S; (* Generate agent name (unique) *)
	let clientKeypair = keypair(C) in (* Generate client key *)
	let serverKeypair = keypair(S) in (* Generate server key *)
	new issuerKeypair;
	let clientCert = cert(C, dec(clientKeypair)) in
	let serverCert = cert(S, dec(serverKeypair)) in
	let issuerCert = cert(S, dec(issuerKeypair)) in
	(
		out(clientInit, (C, clientKeypair, clientCert)) |
		out(serverInit, (S, serverKeypair, serverCert)) |
		out(initChannel, (S, sk(issuerKeypair), issuerCert));
		out(net, S) (* Inform clients of the central server (e.g. IP address) *)
	).
	
(**************************************************************************
 * THE SYSTEM                                                             *
 **************************************************************************)
process
	!initializer | !client | !server