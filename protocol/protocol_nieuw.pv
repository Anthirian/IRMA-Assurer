free C, S.
free c.

(* Diffie-Hellman functions *)
fun f/2.
fun g/1.
equation f(x, g(y)) = f(y, g(x)).

(* Cryptographic functions *)
fun pk/1. (* Retrieves the public part of a kepair *)
fun sk/1. (* Retrieves the secret part of a keypair *)

(* Symmetric key cryptography *)
fun encrypt/2.
reduc decrypt(sencrypt(x, y), y) = x.

(* No public key crypto takes place, keypair is only used for signatures *)
fun pencrypt/2.
reduc pdecrypt(encrypt(x, pk(y)), sk(y)) = x.

(* TLS Symmetric key construction *)
fun generateSymmetricKey/3.

(* Signing functions *)
fun sign/2.
reduc getmess(sign(m, k)) = m. (* TODO: change k to sk(k)? *)

(* Pseudo−random−number function for generating TLS session key randomness *)
fun PRF/1.

(* Certificates *)
private fun cert/2.

(* If cert(x, y) establishes x as owner of key y, y is returned, i.e. this retrieves the public key from the server's certificate *)
reduc verify(cert(x, y), x) = y.

(* Hash functions *)
fun hmac/2.

(* The Server waits for a TLS handshake from a Client *)
let Server =
	(* Server initialization *)
	in(initChannel, (=S, SKs, serverCert));
	
	(* Start of TLS handshake *)
	
	(* Receiving ClientHello *)
	in(c, ClientHello);	let (A, Nc, SupportedOptions) = ClientHello in
	
	(* Server generates a fresh nonce Ns *)
	new Ns;
	
	(* Server picks a cipher suite and compression method from SupportedOptions *)
	new SelectedOptions;
	
	(* Sending ServerHello *)
	let ServerHello = (S, Ns, SelectedOptions) in out(c, ServerHello);
	
	(* Sending server certificate chain *)
	let ServerCertificate = serverCert in out(c, ServerCertificate);
	
	(* Generate Diffie-Hellman Key Exchange parameters *)
	new g;
	new n;
	new y;
	
	(* Sign the parameters *)
	let DH_PARAM_SIG = sign((g, n, g(y)), SKs) in
	
	(* Sending server DH key parameters *)
	let ServerKeyExchange = (g, n, g(y), DH_PARAM_SIG) in out(c, ServerKeyExchange);
	
	(* Create a list of acceptable certificate types and CAs *)
	new acceptable_certificate_types;
	new acceptable_certificate_authorities;
	
	(* Sending ClientCertificateRequest *)
	let ClientCertificateRequest = (acceptable_certificate_types, acceptable_certificate_authorities) in out(c, ClientCertificateRequest);
	
	(* Sending ServerHello Done *)
	out(c, ServerHelloDone);
	
	(* Receiving client certificate chain *)	
	in(c, ClientCertificate); let clientCert = ClientCertificate in
	
	(* Receiving client DH key parameters *)
	in(c, ClientKeyExchange); let gx = ClientKeyExchange in
	
	(* Receiving CertificateVerify *)
	let PKc = verify(clientCert, C) in
    in(c, CertificateVerify); let cvHash = getmess(CertificateVerify, PKc) in	
	
	(* Compute pre-master secret (g^xy) *)
	let PMS = f(gx, g(y)) in
	
	(* Compute master secret, technically also requires "master secret" to be part of the arguments for hashing *)
	let MSs = PRF(PMS, Nc, Ns) in
	
	(* Receiving ClientChangeCipherSpec *)
    in(c, =ClientChangeCipherSpec);
	
	(* Compute hash and session key *)
	let Finished = hash((ClientHello, ServerHello, ServerCertificate, ServerKeyExchange, ClientCertificateRequest, ServerHelloDone, ClientCertificate, ClientKeyExchange, CertificateVerify, ClientChangeCipherSpec)) in
	let sessionKey = generateSymmetricKey(Na, Nb, MSs) in
	
	(* Receiving and verifying ClientFinished *)
	in(c, ClientFinished); let =Finished =decrypt(ClientFinished, sessionKey) in
	
	(* Sending ServerChangeCipherSpec, indicating a switch to the encryption negotiated above. Essentially just 1 byte *) 	
	out(c, ServerChangeCipherSpec);
	
	(* Sending ServerFinished, using the newly negotiated encryption *)
	out(c, Finished);
	
	(* End of TLS handshake *)	
	
	(* Start of application data *)
	
	(* C -> S: {data, C, S, nonce}K_cs, HMAC *)
	
	(* Receive sign-and-verify request from Tablet *)
	in(c, message_from_tablet);
	(* Split up message into content and hmac, and verify integrity *)
	let (message_content, hmac_tablet) = message_from_tablet in
		if hmac_tablet = hmac(message_content, key) then
			(* Check if the correct participants are included (C and S) and store the nonce *)
			event begin(C, S, attributes);
			let (user_specific_data, =C, =S, n) = decrypt(message_content, key) in
				(* Server checks user_specific_data internally *)
				
				(* We assume the data is valid, because checking it is not in the scope of this protocol *)
				
				(* S -> C: {[{attr_1}SK_s, {attr_2}SK_s, ...], C, S, nonce}K_ts, HMAC *)
				(* Send the response message *)
				out(c, ((sign(user_specific_data, key), C, S, n), hmac(sign(user_specific_data, key), key))).
				(* End of application data *)

(* The Client starts the TLS handshake *)
let Client =
	(* Client initialization *)
	in(initChannel, (=C, SKc, clientCert));
	
	(* Start of TLS handshake *)
	
	(* Client generates a fresh nonce Nc *)
	new Nc;
	
	(* Supported cipher suites and compression methods *)
	new SupportedOptions;
	
	(* Sending ClientHello *)
	let ClientHello = (C, Nc, SupportedOptions) in out(c, ClientHello);
	
	(* Receiving ServerHello *)
	in(c, ServerHello); let (S, Ns, SelectedOptions) = ServerHello in
	
	(* Receiving server certificate chain *)
	in(c, ServerCertificate); let serverCert = ServerCertificate in
	
	(* Receiving Server DH Key Parameters and checking integrity *)
	in(c, ServerKeyExchange); let (g, n, gy, DH_PARAM_SIG) = ServerKeyExchange in
	let PKs = verify(serverCert, S) in
	let (=g, =n, =gy) = getmess(DH_PARAM_SIG, PKs) in
	
	(* Receiving ClientCertificateRequest *)
	in(c, ClientCertificateRequest); let (acceptable_certificate_types, acceptable_certificate_authorities) = ClientCertificateRequest in
	
	(* Receiving ServerHelloDone *)
	in(c, =ServerHelloDone);
	
	(* Sending client certificate chain *)
	let ClientCertificate = clientCert in out(c, ClientCertificate);
	
	(* Sending client DH key parameters *)
	new x;
	let g(x) = ClientKeyExchange in out(c, ClientKeyExchange);
	
	(* Sending CertificateVerify *)
	let CertificateVerify = sign(hash((ClientHello, ServerHello, ServerCertificate, ServerKeyExchange, ClientCertificateRequest, ServerHelloDone, ClientCertificate)), SKc) in out(c, CertificateVerify);
	
	(* Compute the pre-master secret (g^xy) *)
	let PMS = f(gy, g(x)) in
	
	(* Compute the master secret, technically also requires "master secret" to be part of the arguments for hashing *)
	let MSc = PRF(PMS, Nc, Ns) in
	
	(* Sending ClientChangeCipherSpec, indicating a switch to the encryption negotiated above. Essentially just 1 byte *)
    out(c, ClientChangeCipherSpec);
	
	(* Compute hash and session key *)
	let Finished = hash((ClientHello, ServerHello, ServerCertificate, ServerKeyExchange, ClientCertificateRequest, ServerHelloDone, ClientCertificate, ClientKeyExchange, CertificateVerify, ClientChangeCipherSpec)) in
	let sessionKey = generateSymmetricKey(Na, Nb, MSs) in
	
	(* Sending ClientFinished *)
	out(c, encrypt(Finished, sessionKey);
	
	(* Receiving ServerChangeCipherSpec, indicating a switch to the encryption negotiated above. Essentially just 1 byte *)
	in(c, =ServerChangeCipherSpec);
	
	(* Receiving and verifying ServerFinished *)
	in(c, ServerFinished); let =Finished =decrypt(ServerFinished, sessionKey) in
	
	(* End of TLS handshake *)
	
	(* Start of application data *)
	
	(* C -> S: {data, C, S, nonce}K_cs, HMAC *)
	
	(* Send encrypted message and its HMAC *)
	new nA;
	out(c, (encrypt((ppData, C, S, nA), key), hmac(ppData, key)));
	
	(* Wait for response *)
	
	(* TODO *)
	(* We also wish to do Active Authentication, which is a challenge-response method using nonces *)
	(* AA should be done before attributes are being created by the server. *)
	
	(* S -> C: {[{attr_1}SK_s, {attr_2}SK_s, ...], C, S, nonce}K_ts, HMAC *)
	in(c, resp);
	
	(* TODO: Rewrite this to be more like TLS (no ifs and no indents) *) 
	
	(* Split up response and verify the HMAC *)
	let (body, hmac_server) = resp in
		if hmac_server = hmac(body, key) then
			(* Decrypt the response body, verify that C, S, and nA are correct and finally store the signed attributes *)
			let (attributes, =C, =S, =nA) = decrypt(body, key) in
				event end(C, S, attributes).
				(* End of application data *)

				
let initializer =
	new clientKeypair;
	new serverKeypair;
	let clientCert = cert(C, sk(clientKeypair)) in
	let serverCert = cert(S, sk(serverKeypair)) in
	out(initChannel, (C, pk(clientKeypair), clientCert));
	out(initChannel, (S, pk(serverKeypair), serverCert)).

process
	(* There are multiple clients, but only one server *)
	initializer | (!Client) | Server
