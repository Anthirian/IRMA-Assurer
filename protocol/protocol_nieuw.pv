free C, S.

(* A public channel *)
free c.

(* Client and Server initialization is done over a private channel *)
private free initChannel.

(* Diffie-Hellman functions *)
fun f/2.
fun g/1.
equation f(x, g(y)) = f(y, g(x)).

(* Cryptographic functions *)
fun pk/1. (* Retrieves the public part of a kepair *)
fun sk/1. (* Retrieves the secret part of a keypair *)

(* Symmetric key cryptography *)
fun encrypt/2.
reduc decrypt(sencrypt(x, y), y) = x.

(* No public key crypto takes place, keypair is only used for signatures *)
fun pencrypt/2.
reduc pdecrypt(encrypt(x, pk(y)), sk(y)) = x.

(* TLS Symmetric key construction *)
fun generateSymmetricKey/3.

(* Signing functions *)
fun sign/2.
reduc unsign(sign(m, sk(x)), pk(x)) = m.

(* Pseudo−random−number function for generating TLS session key randomness *)
fun PRF/1.

(* Certificates *)
private fun cert/2.

(* If cert(x, y) establishes x as owner of key y, y is returned, i.e. this retrieves the public key from the server's certificate *)
reduc verify(cert(x, y), x) = y.

(* Hash functions *)
fun hmac/2.

(* The Server waits for a TLS handshake from a Client *)
let Server =
	(* Server initialization *)
	in(initChannel, (=S, SKs, serverCert));
	
	(* Start of TLS handshake *)
	
	(* Receiving ClientHello *)
	in(c, ClientHello);	let (A, Nc, SupportedOptions) = ClientHello in
	
	(* Server generates a fresh nonce Ns *)
	new Ns;
	
	(* Server picks a cipher suite and compression method from SupportedOptions *)
	new SelectedOptions;
	
	(* Sending ServerHello *)
	let ServerHello = (S, Ns, SelectedOptions) in out(c, ServerHello);
	
	(* Sending server certificate chain *)
	let ServerCertificate = serverCert in out(c, ServerCertificate);
	
	(* Generate Diffie-Hellman Key Exchange parameters *)
	new g;
	new n;
	new y;
	
	(* Sign the parameters *)
	let DH_PARAM_SIG = sign((g, n, g(y)), SKs) in
	
	(* Sending server DH key parameters *)
	let ServerKeyExchange = (g, n, g(y), DH_PARAM_SIG) in out(c, ServerKeyExchange);
	
	(* Create a list of acceptable certificate types and CAs *)
	new acceptable_certificate_types;
	new acceptable_certificate_authorities;
	
	(* Sending ClientCertificateRequest *)
	let ClientCertificateRequest = (acceptable_certificate_types, acceptable_certificate_authorities) in out(c, ClientCertificateRequest);
	
	(* Sending ServerHello Done *)
	out(c, ServerHelloDone);
	
	(* Receiving client certificate chain *)	
	in(c, ClientCertificate); let clientCert = ClientCertificate in
	
	(* Receiving client DH key parameters *)
	in(c, ClientKeyExchange); let gx = ClientKeyExchange in
	
	(* Receiving CertificateVerify *)
	let PKc = verify(clientCert, C) in
    in(c, CertificateVerify); let cvHash = unsign(CertificateVerify, PKc) in	
	
	(* Compute pre-master secret (g^xy) *)
	let PMS = f(gx, g(y)) in
	
	(* Compute master secret, technically also requires "master secret" to be part of the arguments for hashing *)
	let MSs = PRF(PMS, Nc, Ns) in
	
	(* Receiving ClientChangeCipherSpec *)
    in(c, =ClientChangeCipherSpec);
	
	(* Compute hash and session key *)
	let Finished = hash((ClientHello, ServerHello, ServerCertificate, ServerKeyExchange, ClientCertificateRequest, ServerHelloDone, ClientCertificate, ClientKeyExchange, CertificateVerify, ClientChangeCipherSpec)) in
	let sessionKey = generateSymmetricKey(Na, Nb, MSs) in
	
	(* Receiving and verifying ClientFinished *)
	in(c, ClientFinished); let =Finished =decrypt(ClientFinished, sessionKey) in
	
	(* Sending ServerChangeCipherSpec, indicating a switch to the encryption negotiated above. Essentially just 1 byte *) 	
	out(c, ServerChangeCipherSpec);
	
	(* Sending ServerFinished, using the newly negotiated encryption *)
	out(c, Finished);
	
	(* End of TLS handshake *)	
	
	(* Set up a new secure channel encrypted with the newly generated session key *)
	new s;
	out(c, encrypt(s, sessionKey));
	
	(* Start of application data *)
	
	(* Receiving the passport *)
	in(s, ClientPassport); let (EncryptedPassport, HMACPassport) = ClientPassport in
	
	(* Decrypt the passport data *)
	let DecryptedPassport = decrypt(EncryptedPassport, sessionKey) in
	
	(* Verify the HMAC *)
	let =HMACPassport = hmac(EncryptedPassport, sessionKey) in
	
	(* Verify the participants and store the nonce *)
	let (Passport, =C, =S, N) = DecryptedPassport in
	
	(* Split up passport and store public key *)
	(* Note: If BAC is required, everything is inaccessible until BAC is performed *)
	(* We assume BAC is performed once we get to this part *)
	let (DataGroups, SecurityObject, PKp) = Passport in
	
	(* Do Passive Authentication *)
	let =SecurityObject = hash(DataGroups) in
	
	(* TODO: What about the nonce we received? *)
	
	(* Start Active Authentication *)
	new passportChallenge;
	
	
	(* C -> S: {data, C, S, nonce}K_cs, HMAC *)
	
	(* Receive sign-and-verify request from Tablet *)
	in(c, message_from_tablet);
	(* Split up message into content and hmac, and verify integrity *)
	let (message_content, hmac_tablet) = message_from_tablet in
		if hmac_tablet = hmac(message_content, key) then
			(* Check if the correct participants are included (C and S) and store the nonce *)
			event begin(C, S, attributes);
			let (user_specific_data, =C, =S, n) = decrypt(message_content, key) in
				(* Server checks user_specific_data internally *)
				
				(* We assume the data is valid, because checking it is not in the scope of this protocol *)
				
				(* S -> C: {[{attr_1}SK_s, {attr_2}SK_s, ...], C, S, nonce}K_ts, HMAC *)
				(* Send the response message *)
				out(c, ((sign(user_specific_data, key), C, S, n), hmac(sign(user_specific_data, key), key))).
				(* End of application data *)

(* The Client starts the TLS handshake *)
let Client =
	(* Client initialization *)
	in(initChannel, (=C, SKc, clientCert));
	
	(* Start of TLS handshake *)
	
	(* Client generates a fresh nonce Nc *)
	new Nc;
	
	(* Supported cipher suites and compression methods *)
	new SupportedOptions;
	
	(* Sending ClientHello *)
	let ClientHello = (C, Nc, SupportedOptions) in out(c, ClientHello);
	
	(* Receiving ServerHello *)
	in(c, ServerHello); let (S, Ns, SelectedOptions) = ServerHello in
	
	(* Receiving server certificate chain *)
	in(c, ServerCertificate); let serverCert = ServerCertificate in
	
	(* Receiving Server DH Key Parameters and checking integrity *)
	in(c, ServerKeyExchange); let (g, n, gy, DH_PARAM_SIG) = ServerKeyExchange in
	let PKs = verify(serverCert, S) in
	let (=g, =n, =gy) = unsign(DH_PARAM_SIG, PKs) in
	
	(* Receiving ClientCertificateRequest *)
	in(c, ClientCertificateRequest); let (acceptable_certificate_types, acceptable_certificate_authorities) = ClientCertificateRequest in
	
	(* Receiving ServerHelloDone *)
	in(c, =ServerHelloDone);
	
	(* Sending client certificate chain *)
	let ClientCertificate = clientCert in out(c, ClientCertificate);
	
	(* Sending client DH key parameters *)
	new x;
	let g(x) = ClientKeyExchange in out(c, ClientKeyExchange);
	
	(* Sending CertificateVerify *)
	let CertificateVerify = sign(hash((ClientHello, ServerHello, ServerCertificate, ServerKeyExchange, ClientCertificateRequest, ServerHelloDone, ClientCertificate)), SKc) in out(c, CertificateVerify);
	
	(* Compute the pre-master secret (g^xy) *)
	let PMS = f(gy, g(x)) in
	
	(* Compute the master secret, technically also requires "master secret" to be part of the arguments for hashing *)
	let MSc = PRF(PMS, Nc, Ns) in
	
	(* Sending ClientChangeCipherSpec, indicating a switch to the encryption negotiated above. Essentially just 1 byte *)
    out(c, ClientChangeCipherSpec);
	
	(* Compute hash and session key *)
	let Finished = hash((ClientHello, ServerHello, ServerCertificate, ServerKeyExchange, ClientCertificateRequest, ServerHelloDone, ClientCertificate, ClientKeyExchange, CertificateVerify, ClientChangeCipherSpec)) in
	let sessionKey = generateSymmetricKey(Na, Nb, MSs) in
	
	(* Sending ClientFinished *)
	out(c, encrypt(Finished, sessionKey);
	
	(* Receiving ServerChangeCipherSpec, indicating a switch to the encryption negotiated above. Essentially just 1 byte *)
	in(c, =ServerChangeCipherSpec);
	
	(* Receiving and verifying ServerFinished *)
	in(c, ServerFinished); let =Finished = decrypt(ServerFinished, sessionKey) in
	
	(* End of TLS handshake *)
	
	(* Receive the secure channel created by the server *)
	in(c, newChannel); let s = decrypt(newChannel, sessionKey) in
	
	
	(* Start of application data *)
	
	
	
	(* C -> S: {data, C, S, nonce}K_cs, HMAC *)
	
	(* Perform Active Authentication on the passport *)
	
	(* "Create" passport *)
	new DataGroups; (* 16 data groups in total *)
	let SecurityObject = hash(DataGroups) in (* Contains hashes of all DG values *)
	new keypair; (* Public key is stored in DG15 *)
	let Passport = (DataGroups, SecurityObject, pk(keypair)) in
	
	(* Encrypt the passport, reusing the session key *)
	new nA; (* A fresh nonce *)
	let EncryptedPassport = (encrypt(Passport, C, S, nA), sessionKey) in
	
	(* Generate HMAC of the encrypted passport, again reusing the session key *)
	let HMACPassport = hmac(EncryptedPassport, sessionKey) in
	
	(* Send the entire passport data *)
	let ClientPassport = (EncryptedPassport, HMACPassport) in out(s, ClientPassport);
	
	
	(* Wait for challenge from Server *)
		
	(* 
	Passport has keypair. 
	Private key stored in secure memory of chip. 
	Public key stored in SOD file. 
	Server obtains public key.
	Server issues challenge.
	Passport solves challenge using private key. 
	Server checks result using public key
	Active Authentication finished.
	*)
	
	(* S -> C: {[{attr_1}SK_s, {attr_2}SK_s, ...], C, S, nonce}K_ts, HMAC *)
	in(c, resp);
	
	(* TODO: Rewrite this to be more like TLS (no ifs and no indents) *) 
	
	(* Split up response and verify the HMAC *)
	let (body, hmac_server) = resp in
		if hmac_server = hmac(body, key) then
			(* Decrypt the response body, verify that C, S, and nA are correct and finally store the signed attributes *)
			let (attributes, =C, =S, =nA) = decrypt(body, key) in
				event end(C, S, attributes).
				(* End of application data *)

				
let initializer =
	new clientKeypair;
	new serverKeypair;
	let clientCert = cert(C, sk(clientKeypair)) in
	let serverCert = cert(S, sk(serverKeypair)) in
	out(initChannel, (C, pk(clientKeypair), clientCert));
	out(initChannel, (S, pk(serverKeypair), serverCert)).

process
	(* There are multiple clients, but only one server *)
	initializer | (!Client) | Server
