(* A public channel *)
free net.

(* Client and Server initialization is done over a private channel *)
private free initChannel.

(* Message tags *)
free ClientHello, ServerHello, ServerCertificate, ServerKeyExchange, ClientCertificateRequest, ServerHelloDone, ClientCertificate, ClientKeyExchange, CertificateVerify, ClientChangeCipherSpec, ClientFinished, ServerChangeCipherSpec, ServerFinished.

(* Diffie-Hellman functions *)
fun f/2.
fun g/1.
equation f(x, g(y)) = f(y, g(x)).

(* Cryptographic functions *)
fun pk/1. (* Retrieves the public part of a kepair *)
fun sk/1. (* Retrieves the secret part of a keypair *)

(* Symmetric key cryptography *)
fun encrypt/2.
reduc decrypt(encrypt(x, y), y) = x.

(* TLS Symmetric key construction *)
fun generateSymmetricKey/3.

(* Signing functions *)
fun sign/2.
reduc unsign(sign(m, sk(x)), pk(x)) = m.

(* Pseudo−random−number function for generating TLS session key randomness *)
fun PRF/1.

(* Certificates *)
private fun cert/2.

(* If cert(x, y) establishes x as owner of key y, y is returned, i.e. this retrieves the public key from the server's certificate *)
reduc verify(cert(x, y), x) = y.

(* Hash functions *)
fun hash/1.
fun hmac/2.

(* Queries *)

(* secrecy Pre Master secret *)
query attacker: PMS.

(* secrecy Master secret *)
query attacker: MSc.
query attacker: MSs.

(* TODO: Not sure if necessary
secrecy Finished message from the client
query attacker: FinishedAFlag.

secrecy Finished message from the server
query attacker: FinishedBFlag. 
*)

(* authenticity of the server *)
query evinj: endServerAuth(x, y, z) ==> evinj: beginServerAuth(x, y, z).

(* authenticity of the client *)
query evinj: endClientAuth(x, y, z) ==> evinj: beginClientAuth(x, y, z).

(* Passport checks *)
query evinj: endPassiveAuth(x, y, z) ==> evinj: beginPassiveAuth(x, y, z).
query evinj: endActiveAuth(x, y, z) ==> evinj: beginActiveAuth(x, y, z).

(* ABC transaction check *)
query evinj: endTransaction(x, y, z) ==> evinj: beginTransaction(x, y, z).

(* Dead code check *)
query attacker: clientEnd.
query attacker: serverEnd.


(* The Server waits for a TLS handshake from a Client *)
let Server =
	(* Server initialization *)
	in(initChannel, (S, SKs, serverCert));
	in(initChannel, (=S, SKi, issuerCert)); (* TODO: Initialize issuer keypair over separate channel? *)
	(* Start of TLS handshake *)
	
	(* Receiving ClientHello *)
	in(net, CH);	let (=ClientHello, C, Nc, SupportedOptions) = CH in
	
	(* Server generates a fresh nonce Ns *)
	new Ns;
	
	(* Server picks a cipher suite and compression method from SupportedOptions *)
	new SelectedOptions;
	
	(* Sending ServerHello *)
	let SH = (ServerHello, S, Ns, SelectedOptions) in out(net, SH);
	
	(* Sending server certificate chain *)
	let SC = (ServerCertificate, serverCert) in out(net, SC);
	
	(* Generate Diffie-Hellman Key Exchange parameters *)
	new G;
	new N;
	new Y;
	
	(* Sign the parameters *)
	let DHSignature = sign((G, N, g(Y)), SKs) in
	
	(* Sending server DH key parameters *)
	let SKE = (ServerKeyExchange, G, N, g(Y), DHSignature) in out(net, SKE);
	
	(* Create a list of acceptable certificate types and CAs *)
	new acceptable_certificate_types;
	new acceptable_certificate_authorities;
	
	(* Sending ClientCertificateRequest *)
	let CCR = (ClientCertificateRequest, acceptable_certificate_types, acceptable_certificate_authorities) in out(net, CCR);
	
	(* Sending ServerHello Done *)
	let SHD = ServerHelloDone in out(net, SHD);
	
	(* Receiving client certificate chain *)	
	in(net, CC); let (=ClientCertificate, clientCert) = CC in
	
	(* Receiving client DH key parameters *)
	in(net, CKE); let (=ClientKeyExchange, GX) = CKE in
	
	(* Receiving CertificateVerify *)
	let PKc = verify(clientCert, C) in
    in(net, CV); let (=CertificateVerify, cvHash) = unsign(CV, PKc) in
	
	(* Verify hash *)
	let =cvHash = hash((CH, SH, SC, SKE, CCR, SHD, CC)) in
	
	(* End of client authentication *)
	event endClientAuth(C, S, cvHash);
	
	(* Compute pre-master secret (g^xy) *)
	let PMS = f(GX, g(Y)) in
	
	(* Compute master secret, technically also requires "master secret" to be part of the arguments for hashing *)
	let MSs = PRF((PMS, Nc, Ns)) in
	
	(* Receiving ClientChangeCipherSpec *)
    in(net, CCCS); let =ClientChangeCipherSpec = CCCS in
	
	(* Compute hash and session key *)
	let Finished = hash((CH, SH, SC, SKE, CCR, SHD, CC, CKE, CV, CCCS)) in
	
	event beginServerAuth(C, S, PMS);
	
	let sessionKey = generateSymmetricKey(Nc, Ns, MSs) in
	
	(* Receiving and verifying ClientFinished *)
	in(net, CF); let (=ClientFinished, =Finished) = decrypt(CF, sessionKey) in
	
	(* Sending ServerChangeCipherSpec, indicating a switch to the encryption negotiated above. Essentially just 1 byte *) 	
	let SCCS = ServerChangeCipherSpec in out(net, SCCS);
	
	(* Sending ServerFinished, using the newly negotiated encryption *)
	out(net, encrypt((ServerFinished, Finished), sessionKey));
	
	(* End of TLS handshake *)	
	
	(* Set up a new secure channel encrypted with the newly generated session key *)
	new s;
	out(net, encrypt(s, sessionKey));
	
	(* Start of application data *)
	
	(* Receiving the passport *) (* C -> S: {data, C, S, nonce}K_cs, HMAC *)
	in(s, ClientPassport); let (EncryptedPassport, HMACPassport) = ClientPassport in
	
	(* Decrypt the passport data *)
	let DecryptedPassport = decrypt(EncryptedPassport, sessionKey) in
	
	(* Verify the HMAC *)
	let =HMACPassport = hmac(EncryptedPassport, sessionKey) in
	
	(* Verify the participants and store the nonce for after passport checks *)
	let (Passport, =C, =S, Nonce) = DecryptedPassport in
	
	(* Split up passport and store public key *)
	(* Note: If BAC is required, everything is inaccessible until BAC is performed *)
	(* We assume BAC is performed once we get to this part *)
	let (DataGroups, SecurityObject, PKp) = Passport in
	
	(* Do Passive Authentication *)
	let =SecurityObject = hash(DataGroups) in
	
	event endPassiveAuth(C, S, Passport);
	
	(* Start Active Authentication by sending a challenge *)
	new AAChallenge;
	
	event beginActiveAuth(C, S, AAChallenge);
	
	out(s, AAChallenge);
	
	(* Receive the response and verify if it is the correct solution *)
	in(s, AAResponse); let =AAChallenge = unsign(AAResponse, PKp) in
	
	(* The Server assumes the passport to be valid and proceeds with generating ABCs *)
	
	(* Start of ABC logic *)
	
	(* Create a new characteristic, such as "student" or "male" *)
	new Characteristic;
	
	(* Turn the characteristic into an ABC using the issuer's private key *)
	(* TODO: Issuer keypair is initialized, but not being received yet *)
	let AttributeBasedCredential = sign(Characteristic, SKi) in
	
	event beginTransaction(C, S, AttributeBasedCredential);
	
	(* Create attribute data including participants and the previously received nonce *)
	let AttributeData = (AttributeBasedCredential, C, S, Nonce) in
	
	(* Encrypt the attribute data *)
	let EncryptedAttributes = encrypt(AttributeData, sessionKey) in
	
	(* Generate the HMAC over the encrypted data *)
	let HMACAttributes = hmac(EncryptedAttributes, sessionKey) in
	
	(* Send the encrypted data and its HMAC *)
	let ABCs = (EncryptedAttributes, HMACAttributes) in out(s, ABCs);
	
	(* End of ABC logic *)
	
	(* End of application data *)
	
	(* Dead code check *)
	new ServerEnd; out(net, ServerEnd).

(* The Client starts the TLS handshake *)
let Client =
	(* Client initialization *)
	in(initChannel, (C, SKc, clientCert));
	
	(* Start of TLS handshake *)
	
	(* Client generates a fresh nonce Nc *)
	new Nc;
	
	(* Supported cipher suites and compression methods *)
	new SupportedOptions;
	
	(* Sending ClientHello *)
	let CH = (ClientHello, C, Nc, SupportedOptions) in out(net, CH);
	
	(* Receiving ServerHello *)
	in(net, SH); let (=ServerHello, S, Ns, SelectedOptions) = SH in
	
	(* Receiving server certificate chain *)
	in(net, SC); let (=ServerCertificate, serverCert) = SC in
	
	(* Receiving Server DH Key Parameters and checking integrity *)
	in(net, SKE); let (=ServerKeyExchange, G, N, GY, DHSignature) = SKE in
	let PKs = verify(serverCert, S) in
	let (=G, =N, =GY) = unsign(DHSignature, PKs) in
	
	(* Receiving ClientCertificateRequest *)
	in(net, CCR); let (=ClientCertificateRequest, acceptable_certificate_types, acceptable_certificate_authorities) = CCR in
	
	(* Receiving ServerHelloDone *)
	in(net, SHD); let =ServerHelloDone = SHD in
	
	(* Sending client certificate chain *)
	let CC = (ClientCertificate, clientCert) in out(net, CC);
	
	(* Sending client DH key parameters *)
	new x;
	let CKE = (ClientKeyExchange, g(x)) in out(net, CKE);
	
	(* Creating hash of past messages *)
	let cvHash = hash((CH, SH, SC, SKE, CCR, SHD, CC)) in
	
	event beginClientAuth(C, S, cvHash);
	
	(* Sending CertificateVerify *)
	let CV = (sign((CertificateVerify, cvHash), SKc)) in out(net, CV);
	
	(* Compute the pre-master secret (g^xy) *)
	let PMS = f(GY, g(x)) in
	
	(* Compute the master secret, technically also requires "master secret" to be part of the arguments for hashing *)
	let MSc = PRF((PMS, Nc, Ns)) in
	
	(* Sending ClientChangeCipherSpec, indicating a switch to the encryption negotiated above. Essentially just 1 byte *)
    let CCCS = ClientChangeCipherSpec in out(net, CCCS);
	
	(* Compute hash and session key *)
	let Finished = hash((CH, SH, SC, SKE, CCR, SHD, CC, CKE, CV, CCCS)) in
	let sessionKey = generateSymmetricKey(Nc, Ns, MSc) in
	
	(* Sending ClientFinished *)
	let CF = (ClientFinished, encrypt(Finished, sessionKey)) in out(net, CF);
	
	(* Receiving ServerChangeCipherSpec, indicating a switch to the encryption negotiated above. Essentially just 1 byte *)
	in(net, SCCS); let =ServerChangeCipherSpec = SCCS in
	
	(* Receiving and verifying ServerFinished *)
	in(net, SF); let (=ServerFinished, =Finished) = decrypt(SF, sessionKey) in
	
	event endServerAuth(C, S, PMS);
	
	(* End of TLS handshake *)
	
	(* Receive the secure channel created by the server *)
	in(net, newChannel); let s = decrypt(newChannel, sessionKey) in
	
	(* Start of application data *)	
	
	(* C -> S: {data, C, S, nonce}K_cs, HMAC *)
	
	(* Perform Passive + Active Authentication on the passport *)
	
	(* 
	Passport has keypair. 
	Private key stored in secure memory of chip. 
	Public key stored in SOD file. 
	Server obtains public key.
	Server issues challenge.
	Passport solves challenge using private key. 
	Server checks result using public key
	Active Authentication finished.
	*)
	
	(* "Create" passport *)
	new DataGroups; (* 16 data groups in total *)
	let SecurityObject = hash(DataGroups) in (* Contains hashes of all DG values *)
	new keypair; (* Public key is technically stored in DG15 *)
	let Passport = (DataGroups, SecurityObject, pk(keypair)) in
	
	event beginPassiveAuth(C, S, Passport);
	
	(* Encrypt the passport, reusing the session key *)
	new nA; (* A fresh nonce *)
	let EncryptedPassport = encrypt((Passport, C, S, nA), sessionKey) in
	
	(* Generate HMAC of the encrypted passport, again reusing the session key *)
	let HMACPassport = hmac(EncryptedPassport, sessionKey) in
	
	(* Send the entire passport data *)
	let ClientPassport = (EncryptedPassport, HMACPassport) in out(s, ClientPassport);
	
	(* Start of Active Authentication *)
	
	(* Receive challenge from Server *)
	in(s, AAChallenge);
	
	(* Send response to AA challenge *)
	let AAResponse = sign(AAChallenge, sk(keypair)) in out(s, AAResponse);
	
	(* End of Active Authentication *)
	
	(* Start of ABC logic *)
	
	(* S -> C: {[{attr_1}SK_s, {attr_2}SK_s, ...], C, S, nonce}K_ts, HMAC *)
	in(s, ABCs); let (EncryptedAttributes, HMACAttributes) = ABCs in
	
	(* When we receive attributes it is safe to assume active authentication succeeded *)
	event endActiveAuth(C, S, AAChallenge);
	
	(* Check the HMAC *)
	let =HMACAttributes = hmac(EncryptedAttributes, sessionKey) in
	
	(* Decrypt the Attributes *)
	let AttributeData = decrypt(EncryptedAttributes, sessionKey) in
	
	(* Verify the participants and the nonce and store the ABC(s) *)
	let (AttributeBasedCredential, =C, =S, =nA) = AttributeData in
	
	event endTransaction(C, S, AttributeBasedCredential);
	
	(* End of ABC logic *)
	
	(* End of application data *)
	
	(* Dead code check *)
	new clientEnd; out(net, clientEnd).
				
let initializer =
	new clientKeypair;
	new serverKeypair;
	new issuerKeypair;
	let clientCert = cert(C, pk(clientKeypair)) in
	let serverCert = cert(S, pk(serverKeypair)) in
	let issuerCert = cert(S, pk(issuerKeypair)) in
	out(initChannel, (C, sk(clientKeypair), clientCert));
	out(initChannel, (S, sk(serverKeypair), serverCert));
	out(initChannel, (S, sk(issuerKeypair), issuerCert)).

process
	(* There are multiple clients, but only one server *)
	initializer | (!Client) | Server
