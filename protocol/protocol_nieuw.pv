free C, S.

(* A public channel *)
free c.

(* Client and Server initialization is done over a private channel *)
private free initChannel.

(* Diffie-Hellman functions *)
fun f/2.
fun g/1.
equation f(x, g(y)) = f(y, g(x)).

(* Cryptographic functions *)
fun pk/1. (* Retrieves the public part of a kepair *)
fun sk/1. (* Retrieves the secret part of a keypair *)

(* Symmetric key cryptography *)
fun encrypt/2.
reduc decrypt(sencrypt(x, y), y) = x.

(* No public key crypto takes place, keypair is only used for signatures *)
fun pencrypt/2.
reduc pdecrypt(encrypt(x, pk(y)), sk(y)) = x.

(* TLS Symmetric key construction *)
fun generateSymmetricKey/3.

(* Signing functions *)
fun sign/2.
reduc unsign(sign(m, sk(x)), pk(x)) = m.

(* Pseudo−random−number function for generating TLS session key randomness *)
fun PRF/1.

(* Certificates *)
private fun cert/2.

(* If cert(x, y) establishes x as owner of key y, y is returned, i.e. this retrieves the public key from the server's certificate *)
reduc verify(cert(x, y), x) = y.

(* Hash functions *)
fun hmac/2.

(* Queries *)
(* secrecy Pre Master secret *)
query attacker: PMS.

(* secrecy Master secret *)
query attacker: MSc.
query attacker: MSs.

(* Not sure if necessary
secrecy Finished message from the client
query attacker: FinishedAFlag.

secrecy Finished message from the server
query attacker: FinishedBFlag. 
*)

(* authenticity of the server *)
query evinj: endServerAuth(x, y, z) ==> evinj: beginServerAuth(x, y, z).

(* authenticity of the client *)
query evinj: endClientAuth(x, y, z) ==> evinj: beginClientAuth(x, y, z).

(* Passport checks *)
query evinj: endPassiveAuth(x, y, z) ==> evinj: beginPassiveAuth(x, y, z).
query evinj: endActiveAuth(x, y, z) ==> evinj: beginActiveAuth(x, y, z)

(* ABC transaction check *)
query evinj: endTransaction(x, y, z) ==> evinj: beginTransaction(x, y, z)


(* Dead code check *)
query attacker: clientFinished.
query attacker: serverFinished.


(* The Server waits for a TLS handshake from a Client *)
let Server =
	(* Server initialization *)
	in(initChannel, (=S, SKs, serverCert));
	
	(* Start of TLS handshake *)
	
	(* Receiving ClientHello *)
	in(c, ClientHello);	let (A, Nc, SupportedOptions) = ClientHello in
	
	(* Server generates a fresh nonce Ns *)
	new Ns;
	
	(* Server picks a cipher suite and compression method from SupportedOptions *)
	new SelectedOptions;
	
	(* Sending ServerHello *)
	let ServerHello = (S, Ns, SelectedOptions) in out(c, ServerHello);
	
	(* Sending server certificate chain *)
	let ServerCertificate = serverCert in out(c, ServerCertificate);
	
	(* Generate Diffie-Hellman Key Exchange parameters *)
	new g;
	new n;
	new y;
	
	(* Sign the parameters *)
	let DH_PARAM_SIG = sign((g, n, g(y)), SKs) in
	
	(* Sending server DH key parameters *)
	let ServerKeyExchange = (g, n, g(y), DH_PARAM_SIG) in out(c, ServerKeyExchange);
	
	(* Create a list of acceptable certificate types and CAs *)
	new acceptable_certificate_types;
	new acceptable_certificate_authorities;
	
	(* Sending ClientCertificateRequest *)
	let ClientCertificateRequest = (acceptable_certificate_types, acceptable_certificate_authorities) in out(c, ClientCertificateRequest);
	
	(* Sending ServerHello Done *)
	out(c, ServerHelloDone);
	
	(* Receiving client certificate chain *)	
	in(c, ClientCertificate); let clientCert = ClientCertificate in
	
	(* Receiving client DH key parameters *)
	in(c, ClientKeyExchange); let gx = ClientKeyExchange in
	
	(* Receiving CertificateVerify *)
	let PKc = verify(clientCert, C) in
    in(c, CertificateVerify); let cvHash = unsign(CertificateVerify, PKc) in	
	
	(* Verify hash *)
	let =cvHash = hash((ClientHello, ServerHello, ServerCertificate, ServerKeyExchange, ClientCertificateRequest, ServerHelloDone, ClientCertificate)) in
	
	(* End of client authentication *)
	event endClientAuth(C, S, );
	
	(* Compute pre-master secret (g^xy) *)
	let PMS = f(gx, g(y)) in
	
	
	
	(* Compute master secret, technically also requires "master secret" to be part of the arguments for hashing *)
	let MSs = PRF(PMS, Nc, Ns) in
	
	(* Receiving ClientChangeCipherSpec *)
    in(c, =ClientChangeCipherSpec);
	
	(* Compute hash and session key *)
	let Finished = hash((ClientHello, ServerHello, ServerCertificate, ServerKeyExchange, ClientCertificateRequest, ServerHelloDone, ClientCertificate, ClientKeyExchange, CertificateVerify, ClientChangeCipherSpec)) in
	
	event beginServerAuth(C, S, );
	
	let sessionKey = generateSymmetricKey(Na, Nb, MSs) in
	
	(* Receiving and verifying ClientFinished *)
	in(c, ClientFinished); let =Finished =decrypt(ClientFinished, sessionKey) in
	
	(* Sending ServerChangeCipherSpec, indicating a switch to the encryption negotiated above. Essentially just 1 byte *) 	
	out(c, ServerChangeCipherSpec);
	
	(* Sending ServerFinished, using the newly negotiated encryption *)
	out(c, Finished);
	
	(* End of TLS handshake *)	
	
	(* Set up a new secure channel encrypted with the newly generated session key *)
	new s;
	out(c, encrypt(s, sessionKey));
	
	(* Start of application data *)
	
	(* Receiving the passport *) (* C -> S: {data, C, S, nonce}K_cs, HMAC *)
	in(s, ClientPassport); let (EncryptedPassport, HMACPassport) = ClientPassport in
	
	(* Decrypt the passport data *)
	let DecryptedPassport = decrypt(EncryptedPassport, sessionKey) in
	
	(* Verify the HMAC *)
	let =HMACPassport = hmac(EncryptedPassport, sessionKey) in
	
	(* Verify the participants and store the nonce for after passport checks *)
	let (Passport, =C, =S, N) = DecryptedPassport in
	
	(* Split up passport and store public key *)
	(* Note: If BAC is required, everything is inaccessible until BAC is performed *)
	(* We assume BAC is performed once we get to this part *)
	let (DataGroups, SecurityObject, PKp) = Passport in
	
	(* Do Passive Authentication *)
	let =SecurityObject = hash(DataGroups) in
	
	event endPassiveAuth(C, S, Passport);
	
	event beginActiveAuth(C, S, AAChallenge);
	
	(* Start Active Authentication by sending a challenge *)
	new AAChallenge;
	out(s, AAChallenge);
	
	(* Receive the response and verify if it is the correct solution *)
	in(s, AAResponse); let =AAChallenge = unsign(AAResponse, PKp) in
	
	(* The Server assumes the passport to be valid and proceeds with generating ABCs *)
	
	(* Start of ABC logic *)
	
	(* Create a new characteristic, such as "student" or "male" *)
	new Characteristic;
	
	(* Turn the characteristic into an ABC using the issuer's private key *)
	(* TODO: Issuer keypair is initialized, but not being received yet *)
	let AttributeBasedCredential = sign(Characteristic, SKi) in
	
	event beginTransaction(C, S, AttributeBasedCredential);
	
	(* Create attribute data including participants and the previously received nonce *)
	let AttributeData = (AttributeBasedCredential, C, S, N) in
	
	(* Encrypt the attribute data *)
	let EncryptedAttributes = encrypt(AttributeData, sessionKey) in
	
	(* Generate the HMAC over the encrypted data *)
	let HMACAttributes = hmac(EncryptedAttributes, sessionKey) in
	
	(* Send the encrypted data and its HMAC *)
	let ABCs = (EncryptedAttributes, HMACAttributes) in out(s, ABCs);
	
	(* End of ABC logic *)
	
	(* End of application data *)
	
	(* Dead code check *)
	new ServerEnd; out(c, ServerEnd).

(* The Client starts the TLS handshake *)
let Client =
	(* Client initialization *)
	in(initChannel, (=C, SKc, clientCert));
	
	(* Start of TLS handshake *)
	
	(* Client generates a fresh nonce Nc *)
	new Nc;
	
	(* Supported cipher suites and compression methods *)
	new SupportedOptions;
	
	(* Sending ClientHello *)
	let ClientHello = (C, Nc, SupportedOptions) in out(c, ClientHello);
	
	(* Receiving ServerHello *)
	in(c, ServerHello); let (S, Ns, SelectedOptions) = ServerHello in
	
	(* Receiving server certificate chain *)
	in(c, ServerCertificate); let serverCert = ServerCertificate in
	
	(* Receiving Server DH Key Parameters and checking integrity *)
	in(c, ServerKeyExchange); let (g, n, gy, DH_PARAM_SIG) = ServerKeyExchange in
	let PKs = verify(serverCert, S) in
	let (=g, =n, =gy) = unsign(DH_PARAM_SIG, PKs) in	
	
	(* Receiving ClientCertificateRequest *)
	in(c, ClientCertificateRequest); let (acceptable_certificate_types, acceptable_certificate_authorities) = ClientCertificateRequest in
	
	(* Receiving ServerHelloDone *)
	in(c, =ServerHelloDone);
	
	(* Sending client certificate chain *)
	let ClientCertificate = clientCert in out(c, ClientCertificate);
	
	event beginClientAuth(C, S, );
	
	(* Sending client DH key parameters *)
	new x;
	let g(x) = ClientKeyExchange in out(c, ClientKeyExchange);
	
	(* Sending CertificateVerify *)
	let CertificateVerify = sign(hash((ClientHello, ServerHello, ServerCertificate, ServerKeyExchange, ClientCertificateRequest, ServerHelloDone, ClientCertificate)), SKc) in out(c, CertificateVerify);
	
	(* Compute the pre-master secret (g^xy) *)
	let PMS = f(gy, g(x)) in
	
	(* Compute the master secret, technically also requires "master secret" to be part of the arguments for hashing *)
	let MSc = PRF(PMS, Nc, Ns) in
	
	(* Sending ClientChangeCipherSpec, indicating a switch to the encryption negotiated above. Essentially just 1 byte *)
    out(c, ClientChangeCipherSpec);
	
	(* Compute hash and session key *)
	let Finished = hash((ClientHello, ServerHello, ServerCertificate, ServerKeyExchange, ClientCertificateRequest, ServerHelloDone, ClientCertificate, ClientKeyExchange, CertificateVerify, ClientChangeCipherSpec)) in
	let sessionKey = generateSymmetricKey(Na, Nb, MSc) in
	
	(* Sending ClientFinished *)
	out(c, encrypt(Finished, sessionKey));
	
	(* Receiving ServerChangeCipherSpec, indicating a switch to the encryption negotiated above. Essentially just 1 byte *)
	in(c, =ServerChangeCipherSpec);
	
	(* Receiving and verifying ServerFinished *)
	in(c, ServerFinished); let =Finished = decrypt(ServerFinished, sessionKey) in
	
	event endServerAuth(C, S, );
	
	(* End of TLS handshake *)
	
	(* Receive the secure channel created by the server *)
	in(c, newChannel); let s = decrypt(newChannel, sessionKey) in
	
	(* Start of application data *)	
	
	(* C -> S: {data, C, S, nonce}K_cs, HMAC *)
	
	(* Perform Passive + Active Authentication on the passport *)
	
	(* 
	Passport has keypair. 
	Private key stored in secure memory of chip. 
	Public key stored in SOD file. 
	Server obtains public key.
	Server issues challenge.
	Passport solves challenge using private key. 
	Server checks result using public key
	Active Authentication finished.
	*)
	
	(* "Create" passport *)
	new DataGroups; (* 16 data groups in total *)
	let SecurityObject = hash(DataGroups) in (* Contains hashes of all DG values *)
	new keypair; (* Public key is technically stored in DG15 *)
	let Passport = (DataGroups, SecurityObject, pk(keypair)) in
	
	event beginPassiveAuth(C, S, Passport);
	
	(* Encrypt the passport, reusing the session key *)
	new nA; (* A fresh nonce *)
	let EncryptedPassport = (encrypt(Passport, C, S, nA), sessionKey) in
	
	(* Generate HMAC of the encrypted passport, again reusing the session key *)
	let HMACPassport = hmac(EncryptedPassport, sessionKey) in
	
	(* Send the entire passport data *)
	let ClientPassport = (EncryptedPassport, HMACPassport) in out(s, ClientPassport);
	
	(* Start of Active Authentication *)
	
	(* Receive challenge from Server *)
	in(s, AAChallenge);
	
	(* Send response to AA challenge *)
	let AAResponse = sign(AAChallenge, sk(keypair)) in out(s, AAResponse);
	
	(* End of Active Authentication *)
	
	(* Start of ABC logic *)
	
	(* S -> C: {[{attr_1}SK_s, {attr_2}SK_s, ...], C, S, nonce}K_ts, HMAC *)
	in(s, ABCs); let (EncryptedAttributes, HMACAttributes) = ABCs in
	
	(* When we receive attributes it is safe to assume active authentication succeeded *)
	event endActiveAuth(C, S, AAChallenge);
	
	(* Check the HMAC *)
	let =HMACAttributes = hmac(EncryptedAttributes, sessionKey) in
	
	(* Decrypt the Attributes *)
	let AttributeData = decrypt(EncryptedAttributes, sessionKey) in
	
	(* Verify the participants and the nonce and store the ABC(s) *)
	let (AttributeBasedCredential, =C, =S, =nA) = AttributeData in
	
	event endTransaction(C, S, AttributeBasedCredential).
	
	(* End of ABC logic *)
	
	(* End of application data *)

				
let initializer =
	new clientKeypair;
	new serverKeypair;
	new issuerKeypair;
	let clientCert = cert(C, pk(clientKeypair)) in
	let serverCert = cert(S, pk(serverKeypair)) in
	let issuerCert = cert(S, pk(issuerKeypair)) in
	out(initChannel, (C, sk(clientKeypair), clientCert));
	out(initChannel, (S, sk(serverKeypair), serverCert));
	out(initChannel, (S, sk(issuerKeypair), issuerCert)).

process
	(* There are multiple clients, but only one server *)
	initializer | (!Client) | Server
