(* The channel *)
free c.

(* Identifiers and nonces *)
free T, S.

private free key, attributes.

(* Public key derivation *)
fun pk/1.

(* Diffie-Hellman functions *)
fun f/2.
fun g/1.
equation f(x, g(y)) = f(y, g(x)).

(* Cryptographic functions *)
fun encrypt/2.
fun sencrypt/2.

reduc decrypt(encrypt(x, pk(y)), y) = x.
reduc sdecrypt(sencrypt(x, y), y) = x.

(* Signing functions *)
fun sign/2.
reduc getmess(sign(m, k)) = m.
reduc checksign(sign(m, k), pk(k)) = m.

(* Hash functions *)
fun hmac/2.

(* Queries *)
not SK_s.
not SK_t.
not key.
not ppData.
not attributes.

query attacker: attributes.
query attacker: key.
(* 
	Belangrijkste geval van misbruik: 
	Notaris verliest tablet --> Eventuele onterechte aan IRMA kaart toegevoegde attributen moeten ongeldig verklaard worden.	
*)




(* Processes *)
let Tablet =
	(* Store the received public key, not knowing whose it is *)
	in (c, PK_x);
	(* Read out the data on the passport (not part of this protocol) *)
	new ppData;
	
	(* Start of DHKE *)
	
	(* Generate fresh nonce *)
	new n0;
	(* Sign e^n0 and send it, along with your public key *)
	out(c, (sign(g(n0), SK_t), PK_t));
	(* Wait for the response *)
	in(c, m1);
	(* Verify  signature and extract message *)
	let x1 = checksign(m1, PK_x) in
		(* Compute shared key using both nonces and the generator *)
		let key = f(n0, x1) in
		(* Ensure the received public key belongs to the server *)
			if PK_x = PK_s then
				
				(* End of DHKE *)
				
				(* Send encrypted message and its HMAC *)
				new nA;
				out(c, (encrypt((ppData, T, S, nA), key), hmac(ppData, key)));
				
				(* Wait for response *)
				in(c, resp);
				
				(* Split up response and verify the HMAC *)
				let (body, hmac_server) = resp in
					if hmac_server = hmac(body, key) then
						(* Decrypt the response body, verify that T, S, and nA are correct and finally store the signed attributes *)
						let (attributes, =T, =S, =nA) = sdecrypt(body, key) in
							event end(T, S, attributes).

let Server = 
	(* Start of DHKE *)
	
	(* Listen for authentication request *)
	in(c, (m0, PK_y));
	(* Verify signature and extract message *)
	let x0 = checksign(m0, PK_y) in
		(* Create new nonce *)
		new n1;
		(* Compute shared key using both nonces and the generator *)
		let key = f(n1, x0) in
			(* Sign e^n1 and send it, along with your public key *)
			out(c, sign(g(n1), SK_s));
			
			(* End of DHKE *)
			
			(* Receive sign-and-verify request from Tablet *)
			in(c, message_from_tablet);
			(* Split up message into content and hmac, and verify integrity *)
			let (message_content, hmac_tablet) = message_from_tablet in
				if hmac_tablet = hmac(message_content, key) then
					(* Check if the correct participants are included (T and S) and store the nonce *)
					event begin(T, S, attributes);
					let (user_specific_data, =T, =S, n) = sdecrypt(message_content, key) in
						(* Server checks user_specific_data internally *)
						
						(* For now this protocol simply assumes the data is valid *)
						
						(* Send the response message *)
						out(c, ((sign(user_specific_data, key), T, S, n), hmac(sign(user_specific_data, key), key))).

process
	(* Create a public key for both parties *)
	new SK_s;
	let PK_s = pk(SK_s) in
		out(c, PK_s);
		new SK_t;
		let PK_t = pk(SK_t) in
			(* Distribute the public keys *)
			out(c, PK_t);
			(* Start both processes *)
			((!Tablet) | (!Server))









(* 

Assets
----------
- tablet
- server
- burger
- IRMA card
- ID (paspoort / ID-kaart / rijbewijs)


Basic course of events
-------------------------
1. Burger houdt paspoort tegen tablet
2. Tablet leest chipdata uit
+------------------------------------------------------------------------+
| 3. Tablet stuurt chipdata versleuteld naar server                      |
| 4. Server controleert chipdata met gegevens uit interne database       |
| 5. Server ondertekent chipdata                                         |
| 6. Server stuurt ondertekende chipdata versleuteld terug naar tablet   |
+------------------------------------------------------------------------+
7. Burger houdt IRMA card tegen tablet
8. Tablet schrijft ondertekende chipdata naar IRMA card als individuele attributen


Key		crypto type		parties involved
-----------------------------------------
K_pt	symmetric		Passport, Tablet
K_tc	symmetric		Tablet, Card
K_ts	symmetric		Tablet, Server
PK_s	assymmetric		Server (public)
SK_s	assymmetric		Server (secret)
SK_t	assymmetric		Tablet (public)
PK_t	assymmetric		Tablet (secret)
SK_c	assymmetric		Card (public)
PK_c	assymmetric		Card (secret)

Protocol
---------------------------
( T <--> S		Start sessie en verzin sleutel )
( DHKE waarbij de Tablet elke keer dezelfde waarde kiest. Hiermee kun je het ook als authenticatiemethode gebruiken. De server moet dan onthouden welke tablet welke sleutel heeft gebruikt. )
( Zie slides Bart eerstejaars cursus security )

(*	Signed Diffie-Hellman

	A -> B : { e^n0 }skA, pkA    (n0 fresh)
	B -> A : { e^n1 }skB         (n1 fresh)
	A and B compute the key as k = (e^n0)^n1 = (e^n1)^n0
	A -> B : { s }k
 

	- T controleert integriteit ID data
	- T genereert HMAC
	- T versleutelt bericht met sessiesleutel

3. T -> S			{data, T, S, nonce}K_ts, HMAC*

	- S checkt HMAC
	- S checkt T en S
	- S checkt counter/nonce
	- S checkt ID data
	
	- S signt IRMA data
	- S genereert HMAC
	- S versleutelt bericht met sessiesleutel
																
6. S -> T			{[{attr_1}SK_s, {attr_2}SK_s, ...], T, S, nonce}K_ts, HMAC*

	- T checkt HMAC
	- T checkt T en S
	- T checkt counter/nonce
	
	- T verwerkt data tot attributen


* Sterkte van HMAC hangt af van de sterkte van de hashfunctie, de lengte van de hash zelf en van de lengte en sterkte van de gebruikte sleutel (K_ts?).


*)