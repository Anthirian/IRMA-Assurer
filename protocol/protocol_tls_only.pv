	(**************************************************************************
	 * DEFINITIONS                                                            *
	 **************************************************************************)

	(* param verboseClauses = explained. *)
	(* param traceDisplay = long. *)
	 
	(* A public channel *)
	free net.

	(* Message tags *)
	free ClientHello, ClientKeyExchange, ClientCertificate, ServerHello, ServerCertificate, CertificateVerify, ServerKeyExchange.

	(* Agent initialization is done over a private channel *)
	private free clientInit, serverInit.

	(* The cryptographic constructors *)
	fun hash/1. 	(* hashing *)
	fun encrypt/2. 	(* symmetric key encryption *)
	fun sign/2. 	(* Public key signing *)
	fun enc/1. 		(* Extracts encryption key from a keypair *)
	fun dec/1. 		(* Extracts decryption key from a keypair *)

	(* The cryptographic destructors *)
	reduc decrypt(encrypt(x, y), y) = x.
	reduc unsign(sign(x, enc(y)), dec(y)) = x.

	(* A constructor that maps agents to their secret keypairs *)
	private fun keypair/1.

	(* Pseudo−random−number function *)
	fun PRF/1.

	(* Symmetric key construction *)
	fun clientK/3.
	fun serverK/3.

	(* Certificates *)
	private fun cert/2.

	(* If cert(x, y) establishes x as owner of key y, y is returned *)
	reduc verify(cert(x, y), x) = y.
		
	(* Diffie-Hellman computations *)
	fun g/0. 										(* Generator of the group (a constant) *)
	fun exp/2.										(* Exponentiation *)
	equation exp(exp(g, x), y) = exp(exp(g, y), x). (* Equality property *)

	(**************************************************************************
	 * QUERIES 																  *
	 **************************************************************************)
	 
	(* secrecy Pre Master secret *)
	query attacker: PMSa.
	query attacker: PMSb.

	(* secrecy Master secret *)
	query attacker: MSa.
	query attacker: MSb.

	(* secrecy Finished message from the client *)
	query attacker: FinishedAFlag.

	(* secrecy Finished message from the server *)
	query attacker: FinishedBFlag.

	(* authenticity of the server *)
	query evinj: endServerAuth(x, y, z) ==> evinj: beginServerAuth(x, y, z).

	(* authenticity of the client *)
	query evinj: endClientAuth(x, y, z) ==> evinj: beginClientAuth(x, y, z).

	(* Dead code check *)
	query attacker: clientFinished.
	query attacker: serverFinished.

	(**************************************************************************
	 * CLIENT PROCESS, this client is the initiator of the protocol.          *
	 **************************************************************************)
	let client =
		(** Initial agent data from a trusted channel **)
		in(clientInit, (A, keypair, clientCert));
		
		let SKc = enc(keypair) in
		
		(** Get the server’s name, perhaps as user input **)
		in(net, B);
		
		(* A generates fresh nonce Na *)
		new Na;
		
		(* Supported cipher suites and compression methods *)
		new SupportedOptions;
		
		(* A −> B : ClientHello *)
		let CH = (ClientHello, A, Na, SupportedOptions) in out(net, CH);
		
		(* B −> A : ServerHello *)
		in(net, SH); let (=ServerHello, =B, Nb, SelectedOptions) = SH in
		
		(* B −> A : ServerCertificate *)
		in(net, SC); let (=ServerCertificate, serverCert) = SC in
		
		(* Receiving Server DH Key Parameters and checking integrity *)
		in(net, SKE); let (=ServerKeyExchange, g, N, GY, DHSignature) = SKE in
		let unsignKey = verify(serverCert, B) in
		let (=Na, =Nb, =g, =N, =GY) = unsign(DHSignature, unsignKey) in
		
		(* A −> B: ClientCertificate *)
		let CC = (ClientCertificate, clientCert) in out(net, CC);
		
		(* A −> B : ClientKeyExchange *)
		new X;
		let CKE = (ClientKeyExchange, exp(g, X)) in out(net, CKE);
		
		let cvHash = hash((CH, SH, SC, SKE, CC, CKE)) in
		
		(** begin client authentication **)
		event beginClientAuth(A, B, cvHash);
		
		(* A −> B: CertificateVerify *)
		let CV = sign((CertificateVerify, cvHash), SKc) in out(net, CV);
		
		(* Compute the pre-master secret (g^xy) *)
		let PMS = exp(GY, X) in
		
		(* A calculates the Master secret M *)
		let M = PRF((PMS, Na, Nb)) in
		
		(* A calculates Finished *)
		let Finished = hash((CH, SH, SC, SKE, CC, CKE, CV, M)) in
		
		(* A −> B : Finished *)
		out(net, encrypt(Finished, clientK(Na, Nb, M)));
				
		(* B −> A : Finished *)
		in(net, FB);
		(* A verifies received finished *)
		let =Finished = decrypt(FB, serverK(Na, Nb, M)) in
		
		(** end server authentication **)
		event endServerAuth(A, B, Finished);
		
		(* Secrecy checks *)
		(
			(** secrecy check on the Master secret **)
			(new MSa; out(M, MSa)) |
		
			(** secrecy check on the Pre-Master Secret **)
			(new PMSa; out(PMS, PMSa)) |
		
			(** secrecy check on the Finished message **)
			(new FinishedAFlag; out(Finished, FinishedAFlag)) |
		
			(** dead code check **)
			(new clientFinished; out(net, clientFinished))
		).
		
	(**************************************************************************
	 * THE SERVER PROCESS                                                     *
	 **************************************************************************)
	let server =
		(** Initial agent data from a trusted channel **)
		in(serverInit, (B, keypair, serverCert));
		
		let SKs = enc(keypair) in
		
		(** Replication to model arbitrary sessions **)
		!
		
		(* A −> B : ClientHello *)
		in(net, CH); let (=ClientHello, A, Na, SupportedOptions) = CH in
		
		(* B generates fresh nonce Nb *)
		new Nb;
		
		(* Server picks a cipher suite and compression method from SupportedOptions *)
		new SelectedOptions;

		(* B −> A : ServerHello *)
		let SH = (ServerHello, B, Nb, SelectedOptions) in out(net, SH);
		
		(* B −> A : ServerCertificate *)
		let SC = (ServerCertificate, serverCert) in out(net, SC);
		
		(* Generate Diffie-Hellman Key Exchange parameters *)
		new N; (* Modulus (prime), public *)
		new Y; (* Server's secret exponent *)
		
		(* B -> A: ServerKeyExchange *)
		let SKE = (ServerKeyExchange, g, N, exp(g, Y), sign((Na, Nb, g, N, exp(g, Y)), SKs)) in out(net, SKE);
		
		(* A −> B : ClientCertificate *)
		in(net, CC); let (=ClientCertificate, clientCert) = CC in
		
		(* A −> B : ClientKeyExchange *)
		in(net, CKE); let(=ClientKeyExchange, GX) = CKE in
		
		(* A −> B : CertificateVerify *)
		let unsignKey = verify(clientCert, A) in
		in(net, CV); let (=CertificateVerify, cvHash) = unsign(CV, unsignKey) in
		
		(* B verifies client signature *)
		let =cvHash = hash((CH, SH, SC, SKE, CC, CKE)) in
		
		(** end client authentication **)
		event endClientAuth(A, B, cvHash);
		
		(* Calculating the Pre-Master Secret *)
		let PMS = exp(GX, Y) in
		
		(* A −> B : Finished *)
		in(net, FA);
			
		(* B calculates M *)
		let M = PRF((PMS, Na, Nb)) in
		
		(* B calculates Finished *)
		let Finished = hash((CH, SH, SC, SKE, CC, CKE, CV, M)) in
		
		(** server authentication **)
		event beginServerAuth(A, B, Finished);
		
		(* B −> A : Finished *)
		out(net, encrypt(Finished, serverK(Na, Nb, M)));

		(* B verifies received Finished *)
		let =Finished = decrypt(FA, clientK(Na, Nb, M)) in
		
		(* Secrecy checks *)
		(
			(** secrecy check on the Master secret **)
			(new MSb; out(M, MSb)) |
		
			(** secrecy check on the Pre-Master Secret **)
			(new PMSb; out(PMS, PMSb)) |
		
			(** secrecy check on the finished **)
			(new FinishedBFlag; out(Finished, FinishedBFlag)) |
		
			(** dead code check **)
			(new serverFinished; out(net, serverFinished))
		).
		
	(**************************************************************************
	 * THE INITIALIZER PROCESS                                                *
	 **************************************************************************)
	let initializer =
		new C; (* Generate agent name (unique) *)
		new S; (* Generate agent name (unique) *)
		let clientKeypair = keypair(C) in (* Generate client key *)
		let serverKeypair = keypair(S) in (* Generate server key *)
		let clientCert = cert(C, dec(clientKeypair)) in
		let serverCert = cert(S, dec(serverKeypair)) in
		(
			out(clientInit, (C, clientKeypair, clientCert)) |
			out(serverInit, (S, serverKeypair, serverCert)) |
			out(net, S) (* Inform clients of the central server (e.g. IP address) *)
		).
		
	(**************************************************************************
	 * THE SYSTEM                                                             *
	 **************************************************************************)
	process
		!initializer | !client | !server