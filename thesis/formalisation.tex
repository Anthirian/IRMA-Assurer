\section{Formalisation}
\label{sec:formalisation}
In this section we describe the formalisation of the assumptions and use cases into a model written in the Pi Calculus. This model can be proven to be cryptographically secure using ProVerif. We have chosen ProVerif for its ability to automatically analyze the security of cryptographic protocols. ProVerif is capable of proving reachability properties, correspondence assertions, and observational equivalence. These capabilities are particularly useful to the computer security domain since they permit the analysis of secrecy and authentication properties. Moreover, emerging properties such as privacy, traceability, and verifiability can also be considered. Protocol analysis is considered with respect to an unbounded number of sessions and an unbounded message space. Moreover, the tool is capable of attack reconstruction: when a property cannot be proved, ProVerif tries to reconstruct an execution trace that falsifies the desired property~\cite{proverifmanual}.

The model we have constructed for Assurer is listed in appendix~\ref{app:model}. This model is based on the TLS handshake model by Tankink and Vullers~\cite{tankink2008verification}. Their model makes use of RSA for the key exchange, but our model uses Diffie-Hellman. Similarly to their model we make use of message tagging, as is generally considered good practice. Furthermore, ProVerif has trouble finding attacks on variables that are being computed instead of being declared. Tankink and Vullers solve this by creating a new flag variable and outputting this on the supposed-to-be secret. This way when an attacker is able to obtain the flag, then he must have knowledge of the secret and an attack trace can be found. Furthermore we have added dead code checks to the model. This helps determine if the model fails midway. Such a failure is indicated by the fact that no falsification is found by ProVerif. Finally ProVerif appears to have a set a limit on the amount of RAM that it may use. It will not use more than 2GB of RAM, even though plenty is still available, and will consequently report a fatal error. To work around this, we have chosen to split the model into two parts: the first part describes the TLS handshake, while the second part describes the application protocol.

The model consists of three distinct phases. During the first phase the TLS handshake protocol is executed. As explained before we make use of an ephemeral Elliptic Curve Diffie-Hellman (ECDHE) key agreement. This means that in this protocol the only use for both parties' keypair is the signing and verification of messages sent during the key agreement. Because of the nature of Diffie-Hellman, i.e. the Discrete Logarith Problem (DLP), it is not required to encrypt the protocol parameters as they can be sent in the clear without risk of an eavesdropper learning the agreed upon key. For authentication purposes however, we do require these protocol parameters to be signed by the sending party. This allows the receiving party to verify the identity of the sender before starting an encrypted session~\cite{tls1.2,tlsecc}.

The second phase starts the actual Assurer application protocol, which takes place over the encrypted channel for which the key was negotiated during the TLS handshake of phase one. During this phase the passport is verified on the client's side by using passive authentication. This is done by checking the hash stored in the Security Object file of all the data groups contained within the passport. Once the client is confident that the integrity of the passport holds it proceeds by sending the passport data, plus a fresh nonce, to the server via the encrypted channel. The server will then also perform passive authentication as a double-check. If the server agrees with the client on the integrity of the passport, active authentication is performed. To do this, it sends a challenge that the passport has to solve. The passport has to sign this challenge in order to prove it has knowledge of the embedded private key. During passive authentication the server has obtained the passport's public key, which is used to verify the response to the challenge.

The third and final phase of the protocol is where the issuing of the Attribute Based Credentials takes place. As mentioned before the server is the only party that posesses the issuer private key. Every verifier, i.e. a terminal, for example at a supermarket has knowledge of the issuer's public key and is therefore able to verify the signature placed on the ABCs. The issuer's public key is not used in this model, as attribute verification is not included in its scope. The server creates ABCs and encrypts these ABCs, along with the nonce sent by the client during phase two as well as both parties' names, using the session key and computes an HMAC over the result. The encrypted data and its HMAC are sent to the client, which in turn verifies the HMAC and decrypts the data. If the decrypted data is found to match the nonce and the names of both parties, the client accepts the ABCs and stores them onto the IRMA card and closes the session.

\subsection{Discussion}
Here we reflect on the details of the model. This reflection is separated into two parts: the handshake part and the Assurer part. For each part we first describe the different functions we use throughout the model, followed by a description of the queries and finally the parties involved. Should the reader not have experience with ProVerif, we would recommend familiarizing oneself with the basics~\cite{proverifmanual} in order to better understand this section.

\subsubsection{Handshake}
The functions we use for this model are fairly straightforward, apart from the key derivation functions. First of all is a hash function which used for both verification of the client's signature and integrity of the \texttt{finished} messages. We also have encrypt and decrypt functions, which are symmetric and use the generated session key. This model does not use assymmetric cryptography for encryption and decryption. It does however use keypairs and certificates, generated by the \texttt{keypair} and \texttt{cert} function, but these are used for signing and verification of the Diffie-Hellman parameters sent by the server. The public and private parts of a keypair are obtained using the \texttt{pk} and \texttt{sk} functions respectively. It is also important to note that the \texttt{verify} function does not actually verify a message that was signed, but rather retrieves the public key that is included in the certificate. For actually removing the signature and verifying the message the \texttt{unsign} function is used.

Furthermore we have a pseudo-random number function (\texttt{PRF}) which results in an initialization vector when provided with the master secret. With this initialization vector and the functions \texttt{clientK} and \texttt{serverK} the client and server derive the session key respectively. 

Finally we have the Diffie-Hellman functions \texttt{G} and \texttt{sm}. The \texttt{G} function is actually not a function, but a constant instead and represents the generator point of the finite cyclic group of points on the elliptic curve. The \texttt{sm} function allows scalar multiplication. The modulus is abstracted from in this computation, as it is implied and proves to be a large challenge in Pi Calculus. Using the equation defines the relation between the generator point of the group and the coefficients, and results in a usable key agreement scheme.

The query section describes the goals that must be met after checking it with ProVerif. These directly reflect the goals we set in section~\ref{sec:goals}. For the model of TLS handshake we state that an attacker may not learn \texttt{Sa} and \texttt{Sb}, which are flags that both \texttt{A} and \texttt{B} output on the newly generated secure channel \texttt{s}, which is encrypted using the key agreed upon during the execution of the handshake.

The next set of queries state that an attacker may not learn \texttt{PMSa}, \texttt{PMSb}, \texttt{MSa} and \texttt{MSb}. These are four flags, half of which are output by both \texttt{A} and \texttt{B} within the model to allow ProVerif to check that the attacker cannot learn the Pre-Master Secret (\texttt{PMS}) and the Master Secret (\texttt{M}), respectively. These constraints ensure an attacker cannot decrypt the traffic sent over the encrypted channel.

Furthermore we check for the secrecy of the \texttt{Finished} messages sent at the end of the handshake by both parties. These messages are already encrypted with the generated session key and for an attacker to have knowledge of the plaintext would mean the channel is not secure.

Next we check the authentication status for both client and server, as we require mutual authentication. This is achieved by ensuring the events \texttt{endServerAuth} and \texttt{endClientAuth} must always be preceded by the events \texttt{beginServerAuth} and \texttt{beginClientAuth} respectively. These are injective queries, which means that all \texttt{end}-events must be preceded by exactly one \texttt{begin}-event, but it is not required that all \texttt{begin}-events lead to an \texttt{end}-event. For the queries in our model this means that whenever we observe an \texttt{end}-event, and thus assume a party to have authenticated to another, then there must have been a session in which the other party has generated a \texttt{begin}-event. As stated previously, this satisfies mutual authentication between both parties when both queries hold.

Finally, we use two queries to ensure the entire model correctly executes. Essentially the output of \texttt{serverFinished} and \texttt{clientFinished} on a public channel serves as a dead code check. This query must hold, for if it does not then none of the other queries can be considered to have been proved succesfully, since the model has not been verified fully.

Both the \texttt{server} and the \texttt{client} process have been designed to closely resemble the specifications of RFC 5246~\cite{tls1.2}. Differences include message tagging, as mentioned before, for easier reading and ensuring correct execution of the model. The \texttt{server} process also features replication, which allows for multiple parallel runs of the process, in turn allowing the server to accept sessions from multiple clients. This represents the star-architecture of the client-server connections. Note that a \texttt{client} process will always initiate the TLS handshake, since it is the client who requests passport data to be turned into ABCs. Another important difference from the speficiation is that at the end both processes output the flags mentioned above onto a public channel to allow for secrecy and dead code checks.

Apart from the aforementioned two processes there is also the \texttt{initializer} process that is not part of the TLS specification. This process handles the task of setting up keypairs and certificates for both client and server. This initialization takes place on separate (secure) channels, to mimic the pre-loading of certificates and keypairs that takes place when a person applies for a new IRMA card as well as the first (and only) time the server is being set up. To ensure ProVerif has all available non-secret parameters we let the \texttt{initializer} process publish those to a public channel, otherwise some attacks may not be discovered.

\subsubsection{Assurer}
The model of Assurer builds upon the precedents set by the model of the handshake discussed above. Because of the limits set on the RAM usage explained above we have split the model into two parts. The Assurer part therefore has to ensure the properties proven by the handshake part are still true. If this is not the case, the proof of the Assurer part will not hold once the entire model is verified, should ProVerif ever be improved to allow for more RAM to be used. The way we have chosen to circumvent this issue is by keeping the \texttt{client} and \texttt{server} processes intact, but instead of performing the handshake first, we assume we already know about the secret channel \texttt{s} and use that for further communication.

Another change from the handshake model is the fact that the \texttt{initializer} process now also initializes the \texttt{server} process with a secondary keypair used for issuing of ABCs. This issuer keypair is sent over yet another private channel, which means the server cannot mistake one for the other. Also the initializer now generates the session key instead of having both parties agree on one. This is another design choice we have made, since the key agreement has already been proven to be secure in the first part of the model. An attacker thus effectively cannot distinguish the session key in this part of the model from the one agreed upon during the handshake part. 

With this second part of the model also comes a new function. The \texttt{hmac} function is added to ensure the integrity of both passport data and ABCs is kept. We do add any other new functions to our model, but we make use of the functions already present.

The second part of the model also adds several new queries to be proved by ProVerif. First there are two new flags \texttt{passportFlag} and \texttt{abcFlag}, which are used to prove secrecy of the sent passport data and ABCs respectively.

The Assurer model adds new injective queries as well. These injective queries are defined to prove Passive Authentication and Active Authentication for the passport data, as well as ensure no ABCs may ever be sent without completing all required checks beforehand.

Finally we use the same methodology of checking for dead code issues as we did in the handshake model.

The system shows the \texttt{client} process creates a passport object from a DataGroup, which is the internal representation of a passport's data. There are 16 of these DataGroups in total, one of which (DG15) is used for storing the public key of the passport. In our model we have simplified this to a single DataGroup and have created a separate variable to contain the keypair, the public part of which is otherwise stored in DG15. These abstractions are simply to allow for less variables and thus faster verification, without impacting the security proofs. The passport sent to the server therefore contains the DataGroups, a hash of these DataGroups called the Security Object (SOD file) and the public key. Also sent along are both parties' names and a nonce. This passport is protected by an HMAC generated using the session key.

Upon receiving the passport the server checks the hash and thus performs Passive Authentication (PA). Only after PA is performed will the server proceed with Active Authentication. This simply involves the server generating a nonce (challenge) the passport has to sign (response) to prove it has the secret key corresponding to the public key within the passport. 

After both PA and AA are complete the server proceeds by creating ABCs. In the model it creates a single characteristic named \texttt{Char} and signs it using the issuer key. The attribute data is then encrypted along with both parties' names and the previously received nonce. This is then sent to the client along with another HMAC generated using the session key. Upon receiving this the client checks the nonce and the names. At the end of both processes the parties output another flag to verify an attacker cannot obtain the passport data or the ABCs, as well as output the dead code check. Once again, if the dead code check does not pass, the proof of all other queries does not hold.

