\section{Model}
\label{sec:model}
\newcommand{\kwl}[1]{\mathbf{#1}}
\newcommand{\kwf}[1]{\mathsf{#1}}
\newcommand{\kwc}[1]{\mathsf{#1}}
\newcommand{\kwp}[1]{\mathsf{#1}}
\newcommand{\kwt}[1]{\mathsf{#1}}
\newcommand{\kwe}[1]{\mathsf{#1}}
\newcommand{\kwtable}[1]{\mathsf{#1}}
\newcommand{\var}[1]{\mathit{#1}}

\begin{tabbing}
$\kwl{free}\ \kwc{C}, \kwc{S}.$\\
$$\\
$\textit{(* A public channel *)}$\\
$\kwl{free}\ \kwc{c}.$\\
$$\\
$\textit{(* Client and Server initialization is done over a private channel *)}$\\
$\kwl{private}\ \kwl{free}\ \kwc{initChannel}.$\\
$$\\
$\textit{(* Diffie-Hellman functions *)}$\\
$\kwl{fun}\ \kwf{f}/2.$\\
$\kwl{fun}\ \kwf{g}/1.$\\
$\kwl{equation}\ \kwf{f}(\var{x}, \kwf{g}(\var{y})) = \kwf{f}(\var{y}, \kwf{g}(\var{x})).$\\
$$\\
$\textit{(* Cryptographic functions *)}$\\
$\kwl{fun}\ \kwf{pk}/1.\ \textit{(* Retrieves the public part of a kepair *)}$\\
$\kwl{fun}\ \kwf{sk}/1.\ \textit{(* Retrieves the secret part of a keypair *)}$\\
$$\\
$\textit{(* Symmetric key cryptography *)}$\\
$\kwl{fun}\ \kwf{encrypt}/2.$\\
$\kwl{reduc}\ \kwf{decrypt}(\var{sencrypt}(\var{x}, \var{y}), \var{y}) = \var{x}.$\\
$$\\
$\textit{(* No public key crypto takes place, keypair is only used for signatures *)}$\\
$\kwl{fun}\ \kwf{pencrypt}/2.$\\
$\kwl{reduc}\ \kwf{pdecrypt}(\kwf{encrypt}(\var{x}, \kwf{pk}(\var{y})), \kwf{sk}(\var{y})) = \var{x}.$\\
$$\\
$\textit{(* TLS Symmetric key construction *)}$\\
$\kwl{fun}\ \kwf{generateSymmetricKey}/3.$\\
$$\\
$\textit{(* Signing functions *)}$\\
$\kwl{fun}\ \kwf{sign}/2.$\\
$\kwl{reduc}\ \kwf{unsign}(\kwf{sign}(\var{m}, \kwf{sk}(\var{x})), \kwf{pk}(\var{x})) = \var{m}.$\\
$$\\
$\textit{(* Pseudo−random−number function for generating TLS session key randomness *)}$\\
$\kwl{fun}\ \kwf{PRF}/1.$\\
$$\\
$\textit{(* Certificates *)}$\\
$\kwl{private}\ \kwl{fun}\ \kwf{cert}/2.$\\
$$\\
$\textit{(* If cert(x, y) establishes x as owner of key y, y is returned, i.e. this retrieves the public key from the server's certificate *)}$\\
$\kwl{reduc}\ \kwf{verify}(\kwf{cert}(\var{x}, \var{y}), \var{x}) = \var{y}.$\\
$$\\
$\textit{(* Hash functions *)}$\\
$\kwl{fun}\ \kwf{hmac}/2.$\\
$$\\
$\textit{(* The Server waits for a TLS handshake from a Client *)}$\\
$\kwl{let}\ \var{Server} = $\\
$\qquad\qquad \textit{(* Server initialization *)}$\\
$\qquad\qquad \kwl{in}(\kwc{initChannel}, ( =\kwc{S}, \var{SKs}, \var{serverCert}));$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Start of TLS handshake *)}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Receiving ClientHello *)}$\\
$\qquad\qquad \kwl{in}(\kwc{c}, \var{ClientHello});\qquad\qquad \kwl{let}\ (\var{A}, \var{Nc}, \var{SupportedOptions}) = \var{ClientHello}\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Server generates a fresh nonce Ns *)}$\\
$\qquad\qquad \kwl{new}\ \var{Ns};$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Server picks a cipher suite and compression method from SupportedOptions *)}$\\
$\qquad\qquad \kwl{new}\ \var{SelectedOptions};$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Sending ServerHello *)}$\\
$\qquad\qquad \kwl{let}\ \var{ServerHello} = (\kwc{S}, \var{Ns}, \var{SelectedOptions})\ \kwl{in}\ \kwl{out}(\kwc{c}, \var{ServerHello});$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Sending server certificate chain *)}$\\
$\qquad\qquad \kwl{let}\ \var{ServerCertificate} = \var{serverCert}\ \kwl{in}\ \kwl{out}(\kwc{c}, \var{ServerCertificate});$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Generate Diffie-Hellman Key Exchange parameters *)}$\\
$\qquad\qquad \kwl{new}\ \kwf{g};$\\
$\qquad\qquad \kwl{new}\ \var{n};$\\
$\qquad\qquad \kwl{new}\ \var{y};$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Sign the parameters *)}$\\
$\qquad\qquad \kwl{let}\ \var{DH{\_}PARAM{\_}SIG} = \kwf{sign}((\kwf{g}, \var{n}, \kwf{g}(\var{y})), \var{SKs})\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Sending server DH key parameters *)}$\\
$\qquad\qquad \kwl{let}\ \var{ServerKeyExchange} = (\kwf{g}, \var{n}, \kwf{g}(\var{y}), \var{DH{\_}PARAM{\_}SIG})\ \kwl{in}\ \kwl{out}(\kwc{c}, \var{ServerKeyExchange});$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Create a list of acceptable certificate types and CAs *)}$\\
$\qquad\qquad \kwl{new}\ \var{acceptable{\_}certificate{\_}types};$\\
$\qquad\qquad \kwl{new}\ \var{acceptable{\_}certificate{\_}authorities};$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Sending ClientCertificateRequest *)}$\\
$\qquad\qquad \kwl{let}\ \var{ClientCertificateRequest} = (\var{acceptable{\_}certificate{\_}types}, \var{acceptable{\_}certificate{\_}authorities})\ \kwl{in}\ \kwl{out}(\kwc{c}, \var{ClientCertificateRequest});$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Sending ServerHello Done *)}$\\
$\qquad\qquad \kwl{out}(\kwc{c}, \var{ServerHelloDone});$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Receiving client certificate chain *)}\qquad\qquad $\\
$\qquad\qquad \kwl{in}(\kwc{c}, \var{ClientCertificate});\ \kwl{let}\ \var{clientCert} = \var{ClientCertificate}\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Receiving client DH key parameters *)}$\\
$\qquad\qquad \kwl{in}(\kwc{c}, \var{ClientKeyExchange});\ \kwl{let}\ \var{gx} = \var{ClientKeyExchange}\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Receiving CertificateVerify *)}$\\
$\qquad\qquad \kwl{let}\ \var{PKc} = \kwf{verify}(\var{clientCert}, \kwc{C})\ \kwl{in}$\\
$\ \ \ \ \kwl{in}(\kwc{c}, \var{CertificateVerify});\ \kwl{let}\ \var{cvHash} = \kwf{unsign}(\var{CertificateVerify}, \var{PKc})\ \kwl{in}\qquad\qquad $\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Verify hash *)}$\\
$\qquad\qquad \kwl{let} = \var{cvHash} = \var{hash}((\var{ClientHello}, \var{ServerHello}, \var{ServerCertificate}, \var{ServerKeyExchange}, \var{ClientCertificateRequest}, \var{ServerHelloDone}, \var{ClientCertificate}))\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* End of client authentication *)}$\\
$\qquad\qquad \kwl{event}\ \var{endClientAuth}(\var{A}, \var{B}, \var{cvHash});$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Compute pre-master secret (g{\string^}xy) *)}$\\
$\qquad\qquad \kwl{let}\ \var{PMS} = \kwf{f}(\var{gx}, \kwf{g}(\var{y}))\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad $\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Compute master secret, technically also requires "master secret" to be part of the arguments for hashing *)}$\\
$\qquad\qquad \kwl{let}\ \var{MSs} = \kwf{PRF}(\var{PMS}, \var{Nc}, \var{Ns})\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Receiving ClientChangeCipherSpec *)}$\\
$\ \ \ \ \kwl{in}(\kwc{c},  = \var{ClientChangeCipherSpec});$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Compute hash and session key *)}$\\
$\qquad\qquad \kwl{let}\ \var{Finished} = \var{hash}((\var{ClientHello}, \var{ServerHello}, \var{ServerCertificate}, \var{ServerKeyExchange}, \var{ClientCertificateRequest}, \var{ServerHelloDone}, \var{ClientCertificate}, \var{ClientKeyExchange}, \var{CertificateVerify}, \var{ClientChangeCipherSpec}))\ \kwl{in}$\\
$\qquad\qquad \kwl{let}\ \var{sessionKey} = \kwf{generateSymmetricKey}(\var{Na}, \var{Nb}, \var{MSs})\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Receiving and verifying ClientFinished *)}$\\
$\qquad\qquad \kwl{in}(\kwc{c}, \var{ClientFinished});\ \kwl{let} = \var{Finished} = \kwf{decrypt}(\var{ClientFinished}, \var{sessionKey})\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Sending ServerChangeCipherSpec, indicating a switch to the encryption negotiated above. Essentially just 1 byte *)}\ \qquad\qquad $\\
$\qquad\qquad \kwl{out}(\kwc{c}, \var{ServerChangeCipherSpec});$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Sending ServerFinished, using the newly negotiated encryption *)}$\\
$\qquad\qquad \kwl{out}(\kwc{c}, \var{Finished});$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* End of TLS handshake *)}\qquad\qquad $\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Set up a new secure channel encrypted with the newly generated session key *)}$\\
$\qquad\qquad \kwl{new}\ \var{s};$\\
$\qquad\qquad \kwl{out}(\kwc{c}, \kwf{encrypt}(\var{s}, \var{sessionKey}));$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Start of application data *)}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Receiving the passport *)}\ \textit{(* C -\ensuremath{>} S: \ensuremath{\{}data, C, S, nonce\ensuremath{\}}K{\_}cs, HMAC *)}$\\
$\qquad\qquad \kwl{in}(\var{s}, \var{ClientPassport});\ \kwl{let}\ (\var{EncryptedPassport}, \var{HMACPassport}) = \var{ClientPassport}\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Decrypt the passport data *)}$\\
$\qquad\qquad \kwl{let}\ \var{DecryptedPassport} = \kwf{decrypt}(\var{EncryptedPassport}, \var{sessionKey})\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Verify the HMAC *)}$\\
$\qquad\qquad \kwl{let} = \var{HMACPassport} = \kwf{hmac}(\var{EncryptedPassport}, \var{sessionKey})\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Verify the participants and store the nonce for after passport checks *)}$\\
$\qquad\qquad \kwl{let}\ (\var{Passport},  = \kwc{C},  = \kwc{S}, \var{N}) = \var{DecryptedPassport}\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Split up passport and store public key *)}$\\
$\qquad\qquad \textit{(* Note: If BAC is required, everything is inaccessible until BAC is performed *)}$\\
$\qquad\qquad \textit{(* We assume BAC is performed once we get to this part *)}$\\
$\qquad\qquad \kwl{let}\ (\var{DataGroups}, \var{SecurityObject}, \var{PKp}) = \var{Passport}\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Do Passive Authentication *)}$\\
$\qquad\qquad \kwl{let} = \var{SecurityObject} = \var{hash}(\var{DataGroups})\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Start Active Authentication by sending a challenge *)}$\\
$\qquad\qquad \kwl{new}\ \var{passportChallenge};$\\
$\qquad\qquad \kwl{out}(\var{s}, \var{passportChallenge});$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Receive the response and verify if it is the correct solution *)}$\\
$\qquad\qquad \kwl{in}(\var{s}, \var{AAResponse});\ \kwl{let} = \var{passportChallenge} = \kwf{unsign}(\var{AAResponse}, \var{PKp})\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* The Server assumes the passport to be valid and proceeds with generating ABCs *)}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Start of ABC logic *)}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Create a new characteristic, such as "student" or "male" *)}$\\
$\qquad\qquad \kwl{new}\ \var{Characteristic};$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Turn the characteristic into an ABC using the issuer's private key *)}$\\
$\qquad\qquad \textit{(* TODO: Issuer keypair is initialized, but not being received yet *)}$\\
$\qquad\qquad \kwl{let}\ \var{AttributeBasedCredential} = \kwf{sign}(\var{Characteristic}, \var{SKi})\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Create attribute data including participants and the previously received nonce *)}$\\
$\qquad\qquad \kwl{let}\ \var{AttributeData} = (\var{AttributeBasedCredential}, \kwc{C}, \kwc{S}, \var{N})\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Encrypt the attribute data *)}$\\
$\qquad\qquad \kwl{let}\ \var{EncryptedAttributes} = \kwf{encrypt}(\var{AttributeData}, \var{sessionKey})\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Generate the HMAC over the encrypted data *)}$\\
$\qquad\qquad \kwl{let}\ \var{HMACAttributes} = \kwf{hmac}(\var{EncryptedAttributes}, \var{sessionKey})\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Send the encrypted data and its HMAC *)}$\\
$\qquad\qquad \kwl{let}\ \var{ABCs} = (\var{EncryptedAttributes}, \var{HMACAttributes})\ \kwl{in}\ \kwl{out}(\var{s}, \var{ABCs});$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* End of ABC logic *)}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* End of application data *)}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Dead code check *)}$\\
$\qquad\qquad \kwl{new}\ \var{ServerEnd};\ \kwl{out}(\kwc{c}, \var{ServerEnd}).$\\
$$\\
$\textit{(* The Client starts the TLS handshake *)}$\\
$\kwl{let}\ \var{Client} = $\\
$\qquad\qquad \textit{(* Client initialization *)}$\\
$\qquad\qquad \kwl{in}(\kwc{initChannel}, ( = \kwc{C}, \var{SKc}, \var{clientCert}));$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Start of TLS handshake *)}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Client generates a fresh nonce Nc *)}$\\
$\qquad\qquad \kwl{new}\ \var{Nc};$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Supported cipher suites and compression methods *)}$\\
$\qquad\qquad \kwl{new}\ \var{SupportedOptions};$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Sending ClientHello *)}$\\
$\qquad\qquad \kwl{let}\ \var{ClientHello} = (\kwc{C}, \var{Nc}, \var{SupportedOptions})\ \kwl{in}\ \kwl{out}(\kwc{c}, \var{ClientHello});$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Receiving ServerHello *)}$\\
$\qquad\qquad \kwl{in}(\kwc{c}, \var{ServerHello});\ \kwl{let}\ (\kwc{S}, \var{Ns}, \var{SelectedOptions}) = \var{ServerHello}\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Receiving server certificate chain *)}$\\
$\qquad\qquad \kwl{in}(\kwc{c}, \var{ServerCertificate});\ \kwl{let}\ \var{serverCert} = \var{ServerCertificate}\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Receiving Server DH Key Parameters and checking integrity *)}$\\
$\qquad\qquad \kwl{in}(\kwc{c}, \var{ServerKeyExchange});\ \kwl{let}\ (\kwf{g}, \var{n}, \var{gy}, \var{DH{\_}PARAM{\_}SIG}) = \var{ServerKeyExchange}\ \kwl{in}$\\
$\qquad\qquad \kwl{let}\ \var{PKs} = \kwf{verify}(\var{serverCert}, \kwc{S})\ \kwl{in}$\\
$\qquad\qquad \kwl{let}\ ( = \kwf{g},  = \var{n},  = \var{gy}) = \kwf{unsign}(\var{DH{\_}PARAM{\_}SIG}, \var{PKs})\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad $\\
$\qquad\qquad $\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Receiving ClientCertificateRequest *)}$\\
$\qquad\qquad \kwl{in}(\kwc{c}, \var{ClientCertificateRequest});\ \kwl{let}\ (\var{acceptable{\_}certificate{\_}types}, \var{acceptable{\_}certificate{\_}authorities}) = \var{ClientCertificateRequest}\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Receiving ServerHelloDone *)}$\\
$\qquad\qquad \kwl{in}(\kwc{c},  = \var{ServerHelloDone});$\\
$\qquad\qquad $\\
$\qquad\qquad $\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Sending client certificate chain *)}$\\
$\qquad\qquad \kwl{let}\ \var{ClientCertificate} = \var{clientCert}\ \kwl{in}\ \kwl{out}(\kwc{c}, \var{ClientCertificate});$\\
$\qquad\qquad $\\
$\qquad\qquad \kwl{event}\ \var{beginClientAuth}();$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Sending client DH key parameters *)}$\\
$\qquad\qquad \kwl{new}\ \var{x};$\\
$\qquad\qquad \kwl{let}\ \kwf{g}(\var{x}) = \var{ClientKeyExchange}\ \kwl{in}\ \kwl{out}(\kwc{c}, \var{ClientKeyExchange});$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Sending CertificateVerify *)}$\\
$\qquad\qquad \kwl{let}\ \var{CertificateVerify} = \kwf{sign}(\var{hash}((\var{ClientHello}, \var{ServerHello}, \var{ServerCertificate}, \var{ServerKeyExchange}, \var{ClientCertificateRequest}, \var{ServerHelloDone}, \var{ClientCertificate})), \var{SKc})\ \kwl{in}\ \kwl{out}(\kwc{c}, \var{CertificateVerify});$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Compute the pre-master secret (g{\string^}xy) *)}$\\
$\qquad\qquad \kwl{let}\ \var{PMS} = \kwf{f}(\var{gy}, \kwf{g}(\var{x}))\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \kwl{event}\ \var{beginClientAuth}(\kwc{C}, \kwc{S}, \var{PMS});$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Compute the master secret, technically also requires "master secret" to be part of the arguments for hashing *)}$\\
$\qquad\qquad \kwl{let}\ \var{MSc} = \kwf{PRF}(\var{PMS}, \var{Nc}, \var{Ns})\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Sending ClientChangeCipherSpec, indicating a switch to the encryption negotiated above. Essentially just 1 byte *)}$\\
$\ \ \ \ \kwl{out}(\kwc{c}, \var{ClientChangeCipherSpec});$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Compute hash and session key *)}$\\
$\qquad\qquad \kwl{let}\ \var{Finished} = \var{hash}((\var{ClientHello}, \var{ServerHello}, \var{ServerCertificate}, \var{ServerKeyExchange}, \var{ClientCertificateRequest}, \var{ServerHelloDone}, \var{ClientCertificate}, \var{ClientKeyExchange}, \var{CertificateVerify}, \var{ClientChangeCipherSpec}))\ \kwl{in}$\\
$\qquad\qquad \kwl{let}\ \var{sessionKey} = \kwf{generateSymmetricKey}(\var{Na}, \var{Nb}, \var{MSs})\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Sending ClientFinished *)}$\\
$\qquad\qquad \kwl{out}(\kwc{c}, \kwf{encrypt}(\var{Finished}, \var{sessionKey}));$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Receiving ServerChangeCipherSpec, indicating a switch to the encryption negotiated above. Essentially just 1 byte *)}$\\
$\qquad\qquad \kwl{in}(\kwc{c},  = \var{ServerChangeCipherSpec});$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Receiving and verifying ServerFinished *)}$\\
$\qquad\qquad \kwl{in}(\kwc{c}, \var{ServerFinished});\ \kwl{let} = \var{Finished} = \kwf{decrypt}(\var{ServerFinished}, \var{sessionKey})\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* End of TLS handshake *)}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Receive the secure channel created by the server *)}$\\
$\qquad\qquad \kwl{in}(\kwc{c}, \var{newChannel});\ \kwl{let}\ \var{s} = \kwf{decrypt}(\var{newChannel}, \var{sessionKey})\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Start of application data *)}\qquad\qquad $\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* C -\ensuremath{>} S: \ensuremath{\{}data, C, S, nonce\ensuremath{\}}K{\_}cs, HMAC *)}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Perform Passive + Active Authentication on the passport *)}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* }$\\
$\textit{	Passport has keypair. }$\\
$\textit{	Private key stored in secure memory of chip. }$\\
$\textit{	Public key stored in SOD file. }$\\
$\textit{	Server obtains public key.}$\\
$\textit{	Server issues challenge.}$\\
$\textit{	Passport solves challenge using private key. }$\\
$\textit{	Server checks result using public key}$\\
$\textit{	Active Authentication finished.}$\\
$\textit{	*)}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* "Create" passport *)}$\\
$\qquad\qquad \kwl{new}\ \var{DataGroups};\ \textit{(* 16 data groups in total *)}$\\
$\qquad\qquad \kwl{let}\ \var{SecurityObject} = \var{hash}(\var{DataGroups})\ \kwl{in}\ \textit{(* Contains hashes of all DG values *)}$\\
$\qquad\qquad \kwl{new}\ \var{keypair};\ \textit{(* Public key is stored in DG15 *)}$\\
$\qquad\qquad \kwl{let}\ \var{Passport} = (\var{DataGroups}, \var{SecurityObject}, \kwf{pk}(\var{keypair}))\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Encrypt the passport, reusing the session key *)}$\\
$\qquad\qquad \kwl{new}\ \var{nA};\ \textit{(* A fresh nonce *)}$\\
$\qquad\qquad \kwl{let}\ \var{EncryptedPassport} = (\kwf{encrypt}(\var{Passport}, \kwc{C}, \kwc{S}, \var{nA}), \var{sessionKey})\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Generate HMAC of the encrypted passport, again reusing the session key *)}$\\
$\qquad\qquad \kwl{let}\ \var{HMACPassport} = \kwf{hmac}(\var{EncryptedPassport}, \var{sessionKey})\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Send the entire passport data *)}$\\
$\qquad\qquad \kwl{let}\ \var{ClientPassport} = (\var{EncryptedPassport}, \var{HMACPassport})\ \kwl{in}\ \kwl{out}(\var{s}, \var{ClientPassport});$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Start of Active Authentication *)}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Receive challenge from Server *)}$\\
$\qquad\qquad \kwl{in}(\var{s}, \var{AAChallenge});$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Send response to AA challenge *)}$\\
$\qquad\qquad \kwl{let}\ \var{AAResponse} = \kwf{sign}(\var{AAChallenge}, \kwf{sk}(\var{keypair}))\ \kwl{in}\ \kwl{out}(\var{s}, \var{AAResponse});$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* End of Active Authentication *)}\qquad\qquad $\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Start of ABC logic *)}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* S -\ensuremath{>} C: \ensuremath{\{}[\ensuremath{\{}attr{\_}1\ensuremath{\}}SK{\_}s, \ensuremath{\{}attr{\_}2\ensuremath{\}}SK{\_}s, ...], C, S, nonce\ensuremath{\}}K{\_}ts, HMAC *)}$\\
$\qquad\qquad \kwl{in}(\var{s}, \var{ABCs});\ \kwl{let}\ (\var{EncryptedAttributes}, \var{HMACAttributes}) = \var{ABCs}\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Check the HMAC *)}$\\
$\qquad\qquad \kwl{let} = \var{HMACAttributes} = \kwf{hmac}(\var{EncryptedAttributes}, \var{sessionKey})\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Decrypt the Attributes *)}$\\
$\qquad\qquad \kwl{let}\ \var{AttributeData} = \kwf{decrypt}(\var{EncryptedAttributes}, \var{sessionKey})\ \kwl{in}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* Verify the participants and the nonce and store the ABC(s) *)}$\\
$\qquad\qquad \kwl{let}\ (\var{AttributeBasedCredential},  = \kwc{C},  = \kwc{S},  = \var{nA}) = \var{AttributeData}\ \kwl{in}$\\
$\qquad\qquad 0.$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* End of ABC logic *)}$\\
$\qquad\qquad $\\
$\qquad\qquad \textit{(* End of application data *)}$\\
$$\\
$\qquad\qquad \qquad\qquad \qquad\qquad \qquad\qquad $\\
$\kwl{let}\ \var{initializer} = $\\
$\qquad\qquad \kwl{new}\ \var{clientKeypair};$\\
$\qquad\qquad \kwl{new}\ \var{serverKeypair};$\\
$\qquad\qquad \kwl{new}\ \var{issuerKeypair};$\\
$\qquad\qquad \kwl{let}\ \var{clientCert} = \kwf{cert}(\kwc{C}, \kwf{pk}(\var{clientKeypair}))\ \kwl{in}$\\
$\qquad\qquad \kwl{let}\ \var{serverCert} = \kwf{cert}(\kwc{S}, \kwf{pk}(\var{serverKeypair}))\ \kwl{in}$\\
$\qquad\qquad \kwl{let}\ \var{issuerCert} = \kwf{cert}(\kwc{S}, \kwf{pk}(\var{issuerKeypair}))\ \kwl{in}$\\
$\qquad\qquad \kwl{out}(\kwc{initChannel}, (\kwc{C}, \kwf{sk}(\var{clientKeypair}), \var{clientCert}));$\\
$\qquad\qquad \kwl{out}(\kwc{initChannel}, (\kwc{S}, \kwf{sk}(\var{serverKeypair}), \var{serverCert}));$\\
$\qquad\qquad \kwl{out}(\kwc{initChannel}, (\kwc{S}, \kwf{sk}(\var{issuerKeypair}), \var{issuerCert})).$\\
$$\\
$\kwl{process}$\\
$\qquad\qquad \textit{(* There are multiple clients, but only one server *)}$\\
$\qquad\qquad \var{initializer}\mid(!\var{Client})\mid\var{Server}$\\
$$
\end{tabbing}
