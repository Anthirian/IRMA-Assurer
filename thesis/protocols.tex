\section{Protocols}
The IRMA Assurer protocol is an application level protocol. It is designed to run on top of TLS 1.2. Only the latest version of the TLS standard is considered cryptographically secure and therefore is the only version IRMA Assurer supports. A second argument for the use of version 1.2 is the possibility to achieve Perfect Forward Secrecy (PFS), meaning that in case the long term key is ever compromised, then the session keys derived from it before compromise are still secure.~\cite{PFS} This chapter will first describe the TLS protocol, explaining the chosen parameters. The IRMA Assurer protocol follows directly after.

\subsection{Transport Layer Security}
The Transport Layer Security (TLS) protocol is a protocol operating on the presentation layer of the OSI Reference Model.~\cite{osi} It is a protocol that secures the connection between two parties across an insecure channel, ensuring secrecy.~\cite{tls1.2} It also has the possibility for authentication based on certificates. TLS is commonly used in web browsers to encrypt HTTP into HTTPS traffic, but it is capable of protecting any TCP connection.~\cite{lecture}



TLS vulnerable to handshake renegotiation attack, solved by RFC 5746~\cite{lecture}

Bestaat uit twee delen: handshake en record. Handshake maakt gebruik van record. Handshake wordt gebruikt voor het opzetten van een sessie en het onderhandelen van sleutels. Record is het protocol dat zich bezig houdt met de volgorde van bytes (opsplitsen in blokken, comprimeren (optioneel), MAC toepassen, encryptie, fragment headers, en verzenden over poort 443) bij versturen.~\cite{lecture}

\subsubsection{TLS handshake}
\begin{itemize}
  \item 
  \item In het kort (schematisch) uitleggen hoe de handshake verloopt en voor details verwijzen naar de RFC.
\end{itemize}

Below is a schematic overview of the TLS handshake, copied from RFC 5246~\cite{tls1.2}. The \texttt{*} indicates a step necessary for client-to-server authentication. The handshake begins when a client connects to a TLS-enabled server requesting a secure connection and presents a list of supported cipher suites (ciphers and hash functions). From this list, the server picks a cipher and hash function that it also supports and notifies the client of the decision. The server usually then sends back its identification in the form of a digital certificate. The certificate usually contains the server name, the trusted certificate authority (CA) and the server's public encryption key. The client may contact the server that issued the certificate (the trusted CA) and confirm the validity of the certificate before proceeding. In order to generate the session keys used for the secure connection, the client encrypts a random number with the server's public key and sends the result to the server. Only the server should be able to decrypt it, with its private key. From the random number, both parties generate a 'master secret' and then negotiate a session key for encryption and decryption.

The details about the underlying cryptographic functions selected for the IRMA Assurer protocol, such as encryption and hashing functions will be discussed later in section~\ref{sec:assumptions}.
\begin{verbatim}
        Client                                               Server

        ClientHello                  -------->
                                                        ServerHello
                                                       Certificate*
                                                 ServerKeyExchange*
                                                CertificateRequest*
                                     <--------      ServerHelloDone
        Certificate*
        ClientKeyExchange
        CertificateVerify*
        [ChangeCipherSpec]
        Finished                     -------->
                                                 [ChangeCipherSpec]
                                     <--------             Finished
        Application Data             <------->     Application Data
\end{verbatim}


\subsubsection{TLS record}
The record protocol handles the sending and receiving of TLS related messages. It forms the basis of the TLS protocol. When sending, it will split the data in blocks, optionally compress it, apply a MAC, encrypt the data, add a fragment header and finally send the data over TCP port 443. When receiving, it will decrypt the data, verify the MAC, optionally decompress, defragment and finally deliver the data to the upper layer.

This byte ordering for multi-byte values is the commonplace network byte order or big-endian format.~\cite{tls1.2}

\subsubsection{TLS 1.2 changes}
TLS 1.2 was defined in RFC 5246 in August 2008. It is based on the earlier TLS 1.1 specification. Major differences include:

\begin{itemize}
	\item The MD5-SHA-1 combination in the pseudorandom function (PRF) was replaced with SHA-256, with an option to use cipher suite specified PRFs.
  \item The MD5-SHA-1 combination in the finished message hash was replaced with SHA-256, with an option to use cipher suite specific hash algorithms. However the size of the hash in the finished message is still truncated to 96 bits.
  \item The MD5-SHA-1 combination in the digitally signed element was replaced with a single hash negotiated during handshake, which defaults to SHA-1.
  \item Enhancement in the client's and server's ability to specify which hash and signature algorithms they will accept.
  \item Expansion of support for authenticated encryption ciphers, used mainly for Galois / Counter Mode (GCM) and CCM mode of Advanced Encryption Standard encryption.
  \item TLS Extensions definition and Advanced Encryption Standard cipher suites were added.
  \item All TLS versions were further refined in RFC 6176 in March 2011 removing their backward compatibility with SSL such that TLS sessions will never negotiate the use of Secure Sockets Layer (SSL) version 2.0.
\end{itemize}

\subsection{IRMA Assurer}
The IRMA Assurer protocol described below makes use of TLS 1.2 as described above. This means both the server and the tablets will verify each other's certificates and agree upon a session key. Once a secure channel has been successfully set up, we have achieved privacy and data integrity of all communication over this channel.~\cite{tls1.2} 
